var e=Object.defineProperty,t=(t,n,r)=>(((t,n,r)=>{n in t?e(t,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[n]=r})(t,"symbol"!=typeof n?n+"":n,r),r);!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))t(e);new MutationObserver((e=>{for(const n of e)if("childList"===n.type)for(const e of n.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&t(e)})).observe(document,{childList:!0,subtree:!0})}function t(e){if(e.ep)return;e.ep=!0;const t=function(e){const t={};return e.integrity&&(t.integrity=e.integrity),e.referrerPolicy&&(t.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?t.credentials="include":"anonymous"===e.crossOrigin?t.credentials="omit":t.credentials="same-origin",t}(e);fetch(e.href,t)}}();class n{constructor(e,t){this.canvas=e,this.devicePixelRatio=t}async init(e){this.device=await e.requestDevice(),this.context=this.canvas.getContext("webgpu"),this.presentationFormat=navigator.gpu.getPreferredCanvasFormat(),this.context.configure({device:this.device,format:this.presentationFormat,alphaMode:"premultiplied"}),this.colorAttachmentTemplate={view:null,clearValue:{r:1,g:1,b:1,a:1},loadOp:"clear",storeOp:"store"}}get colorAttachment(){return{...this.colorAttachmentTemplate,view:this.context.getCurrentTexture().createView()}}setSize(e,t){this.device&&(this.canvas.width=Math.max(1,Math.min(e,this.device.limits.maxTextureDimension2D)),this.canvas.height=Math.max(1,Math.min(t,this.device.limits.maxTextureDimension2D)))}getSize(){return[this.canvas.width,this.canvas.height]}}class r{constructor(e){t(this,"bindGroups",[]),this.renderer=e;const n=new Float32Array([-1,3,-1,-1,3,-1]);this.vertexBuffer=e.device.createBuffer({label:"post processing pass vertex buffer",size:n.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),new Float32Array(this.vertexBuffer.getMappedRange()).set(n),this.vertexBuffer.unmap();const r=new Float32Array([0,2,0,0,2,0]);this.uvBuffer=e.device.createBuffer({label:"post processing pass uv buffer",size:r.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),new Float32Array(this.uvBuffer.getMappedRange()).set(r),this.uvBuffer.unmap(),this.emptyTexture=e.device.createTexture({label:"empty texture",size:[1,1],dimension:"2d",format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST}),e.device.queue.writeTexture({texture:this.emptyTexture},new Uint8Array(4),{bytesPerRow:4},{width:1,height:1})}async init(e,t,n,r,s){this.renderPipeline=await this.renderer.device.createRenderPipeline({label:e,layout:this.renderer.device.createPipelineLayout({label:`${e} layout`,bindGroupLayouts:[...r]}),primitive:{topology:"triangle-list"},vertex:{entryPoint:"vertex_main",buffers:[{arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,format:"float32x2",offset:0}]},{arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:1,format:"float32x2",offset:0}]}],module:this.renderer.device.createShaderModule({code:"\n\tstruct Inputs {\n\t\t@location(0) position: vec2<f32>,\n\t\t@location(1) uv: vec2<f32>,\n\t}\n\n\tstruct Output {\n\t\t@builtin(position) position: vec4<f32>,\n        @location(0) uv: vec2f\n\t}\n\n\t@vertex\n\tfn vertex_main(input: Inputs) -> Output {\n\t\tvar output: Output;\n\t\toutput.position = vec4(input.position, 0.0, 1.0);\n\t\toutput.uv = input.uv;\n\n\t\treturn output;\n\t}\n"})},fragment:{entryPoint:n,module:this.renderer.device.createShaderModule({code:t}),targets:[{format:s}]}})}setSize(e,t){}render(e){e.setPipeline(this.renderPipeline);for(let t=0;t<this.bindGroups.length;t++)e.setBindGroup(t,this.bindGroups[t]);e.setVertexBuffer(0,this.vertexBuffer),e.setVertexBuffer(1,this.uvBuffer),e.draw(3)}}const s="\n\n@group(0) @binding(0) var colorTexSampler: sampler;\n@group(0) @binding(1) var colorTex: texture_2d<f32>;\n@group(0) @binding(2) var paintTex: texture_2d<f32>;\n\n// Based on: https://www.shadertoy.com/view/ldBfRV\nfn distort(r: vec2<f32>, alpha: f32) -> vec2<f32> {\n    return r + r * -alpha * (1. - dot(r, r) * 1.25);\n}\n\nfn pal(t: f32, a: vec3<f32>, b: vec3<f32>, c: vec3<f32>, d: vec3<f32>) -> vec3<f32> {\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n@fragment\nfn frag_main(@location(0) uv : vec2f) -> @location(0) vec4f {\n    let colorTexSize : vec2f = vec2f(textureDimensions(colorTex));\n    let colorTexelSize = 1. / colorTexSize;\n    \n    // bulge distortion\n    var st: vec2f = uv * 2. - 1.;\n    st *= 0.5;\n    st = distort(st, -1.);\n    st = st * .5 + .5;\n\n    var color : vec4f = textureSample(colorTex, colorTexSampler, st);\n    var paint : vec4f = textureSample(paintTex, colorTexSampler, st);\n    let vel: vec2f = paint.xy;\n    let velLen: f32 = dot(vel, vel);\n    \n    // b/w contour\n    let contourHardness = min(.4, velLen * 20.);\n    var contour: vec3f = 1. - vec3f(smoothstep(0. + contourHardness * .3, .9 - contourHardness, color.g));\n    \n    // emboss effect\n    let embossScale = 2.;\n    let tlColor: vec4f = textureSample(colorTex, colorTexSampler, st + vec2(-colorTexelSize.x,  colorTexelSize.y) * embossScale);\n    let brColor: vec4f = textureSample(colorTex, colorTexSampler, st + vec2(colorTexelSize.x,  -colorTexelSize.y) * embossScale);\n    let c: f32 = smoothstep(0.0, 0.4, color.g);\n    let tl: f32 = smoothstep(0.0, 0.4, tlColor.g);\n    let br: f32 = smoothstep(0.0, 0.4, brColor.g);\n    var emboss: vec3f = vec3f(2.0 * br - c - tl);\n    let luminance: f32 = clamp(0.299 * emboss.r + 0.587 * emboss.g + 0.114 * emboss.b, 0.0, 1.0);\n    emboss = (emboss * .04) + 1.;\n    var ext: vec3f = 1. - vec3f(br + c + tl) / 3.;\n    \n    // main color\n    let t: f32 = ext.r * .01 + contour.r * 1.5 + 0.3 + min(1., velLen * 1.);\n    var base: vec3f = pal(t, vec3(0.5,0.5,0.8),vec3(0.5,0.5,0.65),vec3(1.0,1.0,1.0),vec3(0.,0.33,0.67));\n    base = mix(base, vec3f(1.), smoothstep(0.7, 1., contour.r));\n    // desaturate\n    base = mix(base, vec3(dot(vec3(.3, .59, .11), base)), .4); \n    let contrast = 1.3;\n    let brightness = .1;\n    base = (base - 0.5) * contrast + 0.5 + brightness;\n    let alpha: f32 = smoothstep(0.4, .9, contour.r);\n    base = mix(base, vec3f(0.96, 0.96, 0.97), alpha);\n    \n    // vignette overlay\n    let vignette: f32 = dot(uv * 2. - 1., uv * 2. - 1.);\n    base += vignette * .1;\n\n    return vec4(base * emboss, 1.);\n    //return vec4(ext, 1.);\n}\n\n",i=(e,t)=>((e+t-1)/t|0)*t;const o=e=>e&&"number"==typeof e.length&&e.buffer instanceof ArrayBuffer&&"number"==typeof e.byteLength,a={i32:{numElements:1,align:4,size:4,type:"i32",View:Int32Array},u32:{numElements:1,align:4,size:4,type:"u32",View:Uint32Array},f32:{numElements:1,align:4,size:4,type:"f32",View:Float32Array},f16:{numElements:1,align:2,size:2,type:"u16",View:Uint16Array},vec2f:{numElements:2,align:8,size:8,type:"f32",View:Float32Array},vec2i:{numElements:2,align:8,size:8,type:"i32",View:Int32Array},vec2u:{numElements:2,align:8,size:8,type:"u32",View:Uint32Array},vec2h:{numElements:2,align:4,size:4,type:"u16",View:Uint16Array},vec3i:{numElements:3,align:16,size:12,type:"i32",View:Int32Array},vec3u:{numElements:3,align:16,size:12,type:"u32",View:Uint32Array},vec3f:{numElements:3,align:16,size:12,type:"f32",View:Float32Array},vec3h:{numElements:3,align:8,size:6,type:"u16",View:Uint16Array},vec4i:{numElements:4,align:16,size:16,type:"i32",View:Int32Array},vec4u:{numElements:4,align:16,size:16,type:"u32",View:Uint32Array},vec4f:{numElements:4,align:16,size:16,type:"f32",View:Float32Array},vec4h:{numElements:4,align:8,size:8,type:"u16",View:Uint16Array},mat2x2f:{numElements:4,align:8,size:16,type:"f32",View:Float32Array},mat2x2h:{numElements:4,align:4,size:8,type:"u16",View:Uint16Array},mat3x2f:{numElements:6,align:8,size:24,type:"f32",View:Float32Array},mat3x2h:{numElements:6,align:4,size:12,type:"u16",View:Uint16Array},mat4x2f:{numElements:8,align:8,size:32,type:"f32",View:Float32Array},mat4x2h:{numElements:8,align:4,size:16,type:"u16",View:Uint16Array},mat2x3f:{numElements:8,align:16,size:32,pad:[3,1],type:"f32",View:Float32Array},mat2x3h:{numElements:8,align:8,size:16,pad:[3,1],type:"u16",View:Uint16Array},mat3x3f:{numElements:12,align:16,size:48,pad:[3,1],type:"f32",View:Float32Array},mat3x3h:{numElements:12,align:8,size:24,pad:[3,1],type:"u16",View:Uint16Array},mat4x3f:{numElements:16,align:16,size:64,pad:[3,1],type:"f32",View:Float32Array},mat4x3h:{numElements:16,align:8,size:32,pad:[3,1],type:"u16",View:Uint16Array},mat2x4f:{numElements:8,align:16,size:32,type:"f32",View:Float32Array},mat2x4h:{numElements:8,align:8,size:16,type:"u16",View:Uint16Array},mat3x4f:{numElements:12,align:16,size:48,pad:[3,1],type:"f32",View:Float32Array},mat3x4h:{numElements:12,align:8,size:24,pad:[3,1],type:"u16",View:Uint16Array},mat4x4f:{numElements:16,align:16,size:64,type:"f32",View:Float32Array},mat4x4h:{numElements:16,align:8,size:32,type:"u16",View:Uint16Array},bool:{numElements:0,align:1,size:0,type:"bool",View:Uint32Array}},u={...a,"vec2<i32>":a.vec2i,"vec2<u32>":a.vec2u,"vec2<f32>":a.vec2f,"vec2<f16>":a.vec2h,"vec3<i32>":a.vec3i,"vec3<u32>":a.vec3u,"vec3<f32>":a.vec3f,"vec3<f16>":a.vec3h,"vec4<i32>":a.vec4i,"vec4<u32>":a.vec4u,"vec4<f32>":a.vec4f,"vec4<f16>":a.vec4h,"mat2x2<f32>":a.mat2x2f,"mat2x2<f16>":a.mat2x2h,"mat3x2<f32>":a.mat3x2f,"mat3x2<f16>":a.mat3x2h,"mat4x2<f32>":a.mat4x2f,"mat4x2<f16>":a.mat4x2h,"mat2x3<f32>":a.mat2x3f,"mat2x3<f16>":a.mat2x3h,"mat3x3<f32>":a.mat3x3f,"mat3x3<f16>":a.mat3x3h,"mat4x3<f32>":a.mat4x3f,"mat4x3<f16>":a.mat4x3h,"mat2x4<f32>":a.mat2x4f,"mat2x4<f16>":a.mat2x4h,"mat3x4<f32>":a.mat3x4f,"mat3x4<f16>":a.mat3x4h,"mat4x4<f32>":a.mat4x4f,"mat4x4<f16>":a.mat4x4h},c=(l=u,Object.keys(l));var l,h,f,p,d,_,m,g,y,w;function v(e,t,n,r){const{size:s,type:o}=e;try{const{View:e,align:a}=u[o],c=void 0!==r,l=c?i(s,a):s,h=l/e.BYTES_PER_ELEMENT;return new e(t,n,h*(c?0===r?(t.byteLength-n)/l:r:1))}catch{throw new Error(`unknown type: ${o}`)}}function x(e,t,n){const r=n||0,s=t||new ArrayBuffer(function(e){const t=e;if(t.elementType)return t.size;{const n=e,r=t.numElements||1;if(n.fields)return e.size*r;{const t=e,{align:n}=u[t.type];return r>1?i(e.size,n)*r:e.size}}}(e)),o=(e,t)=>{const n=e,r=n.elementType;if(r){if(function(e){return!e.fields&&!e.elementType}(r)&&u[r.type].flatten)return v(r,s,t,n.numElements);{const{size:a}=S(e),u=0===n.numElements?(s.byteLength-t)/a:n.numElements;return i=e=>o(r,t+a*e),new Array(u).fill(0).map(((e,t)=>i(t)))}}if("string"==typeof e)throw Error("unreachable");{const n=e.fields;if(n){const e={};for(const[r,{type:s,offset:i}]of Object.entries(n))e[r]=o(s,t+i);return e}return v(e,s,t)}var i};return{views:o(e,r),arrayBuffer:s}}function k(e,t){if(void 0!==e)if(o(t)){const n=t;if(1===n.length&&"number"==typeof e)n[0]=e;else if(Array.isArray(e[0])||o(e[0])){const t=e[0].length,r=3===t?4:t;for(let s=0;s<e.length;++s){const t=s*r;n.set(e[s],t)}}else n.set(e)}else if(Array.isArray(t)){const n=t;e.forEach(((e,t)=>{k(e,n[t])}))}else{const n=t;for(const[t,r]of Object.entries(e)){const e=n[t];e&&k(r,e)}}}function b(e,t,n=0){const r=e,s=x(void 0===r.group?e:r.typeDefinition,t,n);return{...s,set(e){k(e,s.views)}}}function T(e){const t=e.elementType;if(t)return T(t);const n=e.fields;if(n)return Object.values(n).reduce(((e,{type:t})=>Math.max(e,T(t))),0);const{type:r}=e,{align:s}=u[r];return s}function S(e){const t=e.elementType;if(t){const e=t.size,n=T(t);return{unalignedSize:e,align:n,size:i(e,n)}}const n=e.fields;if(n){const e=Object.values(n).pop();if(0===e.type.size)return S(e.type)}return{size:0,unalignedSize:0,align:1}}!function(e=[],t){const n=new Set;for(const r of c){const s=u[r];n.has(s)||(n.add(s),s.flatten=e.includes(r)?t:!t)}}();class E{constructor(){this.constants=new Map,this.aliases=new Map,this.structs=new Map}}class A{constructor(){}get isAstNode(){return!0}get astNodeType(){return""}evaluate(e){throw new Error("Cannot evaluate node")}evaluateString(e){return this.evaluate(e).toString()}search(e){}searchBlock(e,t){if(e){t(z.instance);for(const n of e)n instanceof Array?this.searchBlock(n,t):n.search(t);t(I.instance)}}}class z extends A{}z.instance=new z;class I extends A{}I.instance=new I;class M extends A{constructor(){super()}}class P extends M{constructor(e,t,n,r){super(),this.name=e,this.args=t,this.returnType=n,this.body=r}get astNodeType(){return"function"}search(e){this.searchBlock(this.body,e)}}class U extends M{constructor(e){super(),this.expression=e}get astNodeType(){return"staticAssert"}search(e){this.expression.search(e)}}class B extends M{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"while"}search(e){this.condition.search(e),this.searchBlock(this.body,e)}}class V extends M{constructor(e){super(),this.body=e}get astNodeType(){return"continuing"}search(e){this.searchBlock(this.body,e)}}class G extends M{constructor(e,t,n,r){super(),this.init=e,this.condition=t,this.increment=n,this.body=r}get astNodeType(){return"for"}search(e){var t,n,r;null===(t=this.init)||void 0===t||t.search(e),null===(n=this.condition)||void 0===n||n.search(e),null===(r=this.increment)||void 0===r||r.search(e),this.searchBlock(this.body,e)}}class N extends M{constructor(e,t,n,r,s){super(),this.name=e,this.type=t,this.storage=n,this.access=r,this.value=s}get astNodeType(){return"var"}search(e){var t;e(this),null===(t=this.value)||void 0===t||t.search(e)}}class O extends M{constructor(e,t,n){super(),this.name=e,this.type=t,this.value=n}get astNodeType(){return"override"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class q extends M{constructor(e,t,n,r,s){super(),this.name=e,this.type=t,this.storage=n,this.access=r,this.value=s}get astNodeType(){return"let"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class D extends M{constructor(e,t,n,r,s){super(),this.name=e,this.type=t,this.storage=n,this.access=r,this.value=s}get astNodeType(){return"const"}evaluate(e){return this.value.evaluate(e)}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}(f=h||(h={})).increment="++",f.decrement="--",function(e){e.parse=function(t){const n=t;if("parse"==n)throw new Error("Invalid value for IncrementOperator");return e[n]}}(h||(h={}));class R extends M{constructor(e,t){super(),this.operator=e,this.variable=t}get astNodeType(){return"increment"}search(e){this.variable.search(e)}}(d=p||(p={})).assign="=",d.addAssign="+=",d.subtractAssin="-=",d.multiplyAssign="*=",d.divideAssign="/=",d.moduloAssign="%=",d.andAssign="&=",d.orAssign="|=",d.xorAssign="^=",d.shiftLeftAssign="<<=",d.shiftRightAssign=">>=",(p||(p={})).parse=function(e){const t=e;if("parse"==t)throw new Error("Invalid value for AssignOperator");return t};class F extends M{constructor(e,t,n){super(),this.operator=e,this.variable=t,this.value=n}get astNodeType(){return"assign"}search(e){this.value.search(e)}}class L extends M{constructor(e,t){super(),this.name=e,this.args=t}get astNodeType(){return"call"}}class C extends M{constructor(e,t){super(),this.body=e,this.continuing=t}get astNodeType(){return"loop"}}class j extends M{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"body"}}class $ extends M{constructor(e,t,n,r){super(),this.condition=e,this.body=t,this.elseif=n,this.else=r}get astNodeType(){return"if"}search(e){this.condition.search(e),this.searchBlock(this.body,e),this.searchBlock(this.elseif,e),this.searchBlock(this.else,e)}}class Y extends M{constructor(e){super(),this.value=e}get astNodeType(){return"return"}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class W extends M{constructor(e){super(),this.name=e}get astNodeType(){return"enable"}}class X extends M{constructor(e,t){super(),this.name=e,this.type=t}get astNodeType(){return"alias"}}class H extends M{constructor(){super()}get astNodeType(){return"discard"}}class K extends M{constructor(){super()}get astNodeType(){return"break"}}class Z extends M{constructor(){super()}get astNodeType(){return"continue"}}class J extends M{constructor(e){super(),this.name=e}get astNodeType(){return"type"}get isStruct(){return!1}get isArray(){return!1}}class Q extends J{constructor(e,t){super(e),this.members=t}get astNodeType(){return"struct"}get isStruct(){return!0}getMemberIndex(e){for(let t=0;t<this.members.length;t++)if(this.members[t].name==e)return t;return-1}}class ee extends J{constructor(e,t,n){super(e),this.format=t,this.access=n}get astNodeType(){return"template"}}class te extends J{constructor(e,t,n,r){super(e),this.storage=t,this.type=n,this.access=r}get astNodeType(){return"pointer"}}class ne extends J{constructor(e,t,n,r){super(e),this.attributes=t,this.format=n,this.count=r}get astNodeType(){return"array"}get isArray(){return!0}}class re extends J{constructor(e,t,n){super(e),this.format=t,this.access=n}get astNodeType(){return"sampler"}}class se extends A{constructor(){super()}}class ie extends se{constructor(e){super(),this.value=e}get astNodeType(){return"stringExpr"}toString(){return this.value}evaluateString(){return this.value}}class oe extends se{constructor(e,t){super(),this.type=e,this.args=t}get astNodeType(){return"createExpr"}}class ae extends se{constructor(e,t){super(),this.name=e,this.args=t}get astNodeType(){return"callExpr"}evaluate(e){switch(this.name){case"abs":return Math.abs(this.args[0].evaluate(e));case"acos":return Math.acos(this.args[0].evaluate(e));case"acosh":return Math.acosh(this.args[0].evaluate(e));case"asin":return Math.asin(this.args[0].evaluate(e));case"asinh":return Math.asinh(this.args[0].evaluate(e));case"atan":return Math.atan(this.args[0].evaluate(e));case"atan2":return Math.atan2(this.args[0].evaluate(e),this.args[1].evaluate(e));case"atanh":return Math.atanh(this.args[0].evaluate(e));case"ceil":return Math.ceil(this.args[0].evaluate(e));case"clamp":return Math.min(Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e)),this.args[2].evaluate(e));case"cos":return Math.cos(this.args[0].evaluate(e));case"degrees":return 180*this.args[0].evaluate(e)/Math.PI;case"distance":return Math.sqrt(Math.pow(this.args[0].evaluate(e)-this.args[1].evaluate(e),2));case"dot":case"exp":return Math.exp(this.args[0].evaluate(e));case"exp2":return Math.pow(2,this.args[0].evaluate(e));case"floor":return Math.floor(this.args[0].evaluate(e));case"fma":return this.args[0].evaluate(e)*this.args[1].evaluate(e)+this.args[2].evaluate(e);case"fract":case"modf":return this.args[0].evaluate(e)-Math.floor(this.args[0].evaluate(e));case"inverseSqrt":return 1/Math.sqrt(this.args[0].evaluate(e));case"log":return Math.log(this.args[0].evaluate(e));case"log2":return Math.log2(this.args[0].evaluate(e));case"max":return Math.max(this.args[0].evaluate(e),this.args[1].evaluate(e));case"min":return Math.min(this.args[0].evaluate(e),this.args[1].evaluate(e));case"mix":return this.args[0].evaluate(e)*(1-this.args[2].evaluate(e))+this.args[1].evaluate(e)*this.args[2].evaluate(e);case"pow":return Math.pow(this.args[0].evaluate(e),this.args[1].evaluate(e));case"radians":return this.args[0].evaluate(e)*Math.PI/180;case"round":return Math.round(this.args[0].evaluate(e));case"sign":return Math.sign(this.args[0].evaluate(e));case"sin":return Math.sin(this.args[0].evaluate(e));case"sinh":return Math.sinh(this.args[0].evaluate(e));case"saturate":return Math.min(Math.max(this.args[0].evaluate(e),0),1);case"smoothstep":return this.args[0].evaluate(e)*this.args[0].evaluate(e)*(3-2*this.args[0].evaluate(e));case"sqrt":return Math.sqrt(this.args[0].evaluate(e));case"step":return this.args[0].evaluate(e)<this.args[1].evaluate(e)?0:1;case"tan":return Math.tan(this.args[0].evaluate(e));case"tanh":return Math.tanh(this.args[0].evaluate(e));case"trunc":return Math.trunc(this.args[0].evaluate(e));default:throw new Error("Non const function: "+this.name)}}search(e){for(const t of this.args)t.search(e);e(this)}}class ue extends se{constructor(e){super(),this.name=e}get astNodeType(){return"varExpr"}search(e){e(this)}}class ce extends se{constructor(e,t){super(),this.name=e,this.initializer=t}get astNodeType(){return"constExpr"}evaluate(e){var t,n;if(this.initializer instanceof oe){const r=null===(t=this.postfix)||void 0===t?void 0:t.evaluateString(e),s=null===(n=this.initializer.type)||void 0===n?void 0:n.name,i=e.structs.get(s),o=null==i?void 0:i.getMemberIndex(r);if(-1!=o){return this.initializer.args[o].evaluate(e)}console.log(o)}return this.initializer.evaluate(e)}search(e){this.initializer.search(e)}}class le extends se{constructor(e){super(),this.value=e}get astNodeType(){return"literalExpr"}evaluate(){return this.value}}class he extends se{constructor(e,t){super(),this.type=e,this.value=t}get astNodeType(){return"bitcastExpr"}search(e){this.value.search(e)}}class fe extends se{constructor(e,t){super(),this.type=e,this.args=t}get astNodeType(){return"typecastExpr"}evaluate(e){return this.args[0].evaluate(e)}search(e){this.searchBlock(this.args,e)}}class pe extends se{constructor(e){super(),this.contents=e}get astNodeType(){return"groupExpr"}evaluate(e){return this.contents[0].evaluate(e)}search(e){this.searchBlock(this.contents,e)}}class de extends se{constructor(){super()}}class _e extends de{constructor(e,t){super(),this.operator=e,this.right=t}get astNodeType(){return"unaryOp"}evaluate(e){switch(this.operator){case"+":return this.right.evaluate(e);case"-":return-this.right.evaluate(e);case"!":return this.right.evaluate(e)?0:1;case"~":return~this.right.evaluate(e);default:throw new Error("Unknown unary operator: "+this.operator)}}search(e){this.right.search(e)}}class me extends de{constructor(e,t,n){super(),this.operator=e,this.left=t,this.right=n}get astNodeType(){return"binaryOp"}evaluate(e){switch(this.operator){case"+":return this.left.evaluate(e)+this.right.evaluate(e);case"-":return this.left.evaluate(e)-this.right.evaluate(e);case"*":return this.left.evaluate(e)*this.right.evaluate(e);case"/":return this.left.evaluate(e)/this.right.evaluate(e);case"%":return this.left.evaluate(e)%this.right.evaluate(e);case"==":return this.left.evaluate(e)==this.right.evaluate(e)?1:0;case"!=":return this.left.evaluate(e)!=this.right.evaluate(e)?1:0;case"<":return this.left.evaluate(e)<this.right.evaluate(e)?1:0;case">":return this.left.evaluate(e)>this.right.evaluate(e)?1:0;case"<=":return this.left.evaluate(e)<=this.right.evaluate(e)?1:0;case">=":return this.left.evaluate(e)>=this.right.evaluate(e)?1:0;case"&&":return this.left.evaluate(e)&&this.right.evaluate(e)?1:0;case"||":return this.left.evaluate(e)||this.right.evaluate(e)?1:0;default:throw new Error(`Unknown operator ${this.operator}`)}}search(e){this.left.search(e),this.right.search(e)}}class ge extends A{constructor(){super()}}class ye extends ge{constructor(e,t){super(),this.selector=e,this.body=t}get astNodeType(){return"case"}search(e){this.searchBlock(this.body,e)}}class we extends ge{constructor(e){super(),this.body=e}get astNodeType(){return"default"}search(e){this.searchBlock(this.body,e)}}class ve extends A{constructor(e,t,n){super(),this.name=e,this.type=t,this.attributes=n}get astNodeType(){return"argument"}}class xe extends A{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return"elseif"}search(e){this.condition.search(e),this.searchBlock(this.body,e)}}class ke extends A{constructor(e,t,n){super(),this.name=e,this.type=t,this.attributes=n}get astNodeType(){return"member"}}class be extends A{constructor(e,t){super(),this.name=e,this.value=t}get astNodeType(){return"attribute"}}(g=m||(m={}))[g.token=0]="token",g[g.keyword=1]="keyword",g[g.reserved=2]="reserved";class Te{constructor(e,t,n){this.name=e,this.type=t,this.rule=n}toString(){return this.name}}class Se{}_=Se,Se.none=new Te("",m.reserved,""),Se.eof=new Te("EOF",m.token,""),Se.reserved={asm:new Te("asm",m.reserved,"asm"),bf16:new Te("bf16",m.reserved,"bf16"),do:new Te("do",m.reserved,"do"),enum:new Te("enum",m.reserved,"enum"),f16:new Te("f16",m.reserved,"f16"),f64:new Te("f64",m.reserved,"f64"),handle:new Te("handle",m.reserved,"handle"),i8:new Te("i8",m.reserved,"i8"),i16:new Te("i16",m.reserved,"i16"),i64:new Te("i64",m.reserved,"i64"),mat:new Te("mat",m.reserved,"mat"),premerge:new Te("premerge",m.reserved,"premerge"),regardless:new Te("regardless",m.reserved,"regardless"),typedef:new Te("typedef",m.reserved,"typedef"),u8:new Te("u8",m.reserved,"u8"),u16:new Te("u16",m.reserved,"u16"),u64:new Te("u64",m.reserved,"u64"),unless:new Te("unless",m.reserved,"unless"),using:new Te("using",m.reserved,"using"),vec:new Te("vec",m.reserved,"vec"),void:new Te("void",m.reserved,"void")},Se.keywords={array:new Te("array",m.keyword,"array"),atomic:new Te("atomic",m.keyword,"atomic"),bool:new Te("bool",m.keyword,"bool"),f32:new Te("f32",m.keyword,"f32"),i32:new Te("i32",m.keyword,"i32"),mat2x2:new Te("mat2x2",m.keyword,"mat2x2"),mat2x3:new Te("mat2x3",m.keyword,"mat2x3"),mat2x4:new Te("mat2x4",m.keyword,"mat2x4"),mat3x2:new Te("mat3x2",m.keyword,"mat3x2"),mat3x3:new Te("mat3x3",m.keyword,"mat3x3"),mat3x4:new Te("mat3x4",m.keyword,"mat3x4"),mat4x2:new Te("mat4x2",m.keyword,"mat4x2"),mat4x3:new Te("mat4x3",m.keyword,"mat4x3"),mat4x4:new Te("mat4x4",m.keyword,"mat4x4"),ptr:new Te("ptr",m.keyword,"ptr"),sampler:new Te("sampler",m.keyword,"sampler"),sampler_comparison:new Te("sampler_comparison",m.keyword,"sampler_comparison"),struct:new Te("struct",m.keyword,"struct"),texture_1d:new Te("texture_1d",m.keyword,"texture_1d"),texture_2d:new Te("texture_2d",m.keyword,"texture_2d"),texture_2d_array:new Te("texture_2d_array",m.keyword,"texture_2d_array"),texture_3d:new Te("texture_3d",m.keyword,"texture_3d"),texture_cube:new Te("texture_cube",m.keyword,"texture_cube"),texture_cube_array:new Te("texture_cube_array",m.keyword,"texture_cube_array"),texture_multisampled_2d:new Te("texture_multisampled_2d",m.keyword,"texture_multisampled_2d"),texture_storage_1d:new Te("texture_storage_1d",m.keyword,"texture_storage_1d"),texture_storage_2d:new Te("texture_storage_2d",m.keyword,"texture_storage_2d"),texture_storage_2d_array:new Te("texture_storage_2d_array",m.keyword,"texture_storage_2d_array"),texture_storage_3d:new Te("texture_storage_3d",m.keyword,"texture_storage_3d"),texture_depth_2d:new Te("texture_depth_2d",m.keyword,"texture_depth_2d"),texture_depth_2d_array:new Te("texture_depth_2d_array",m.keyword,"texture_depth_2d_array"),texture_depth_cube:new Te("texture_depth_cube",m.keyword,"texture_depth_cube"),texture_depth_cube_array:new Te("texture_depth_cube_array",m.keyword,"texture_depth_cube_array"),texture_depth_multisampled_2d:new Te("texture_depth_multisampled_2d",m.keyword,"texture_depth_multisampled_2d"),texture_external:new Te("texture_external",m.keyword,"texture_external"),u32:new Te("u32",m.keyword,"u32"),vec2:new Te("vec2",m.keyword,"vec2"),vec3:new Te("vec3",m.keyword,"vec3"),vec4:new Te("vec4",m.keyword,"vec4"),bitcast:new Te("bitcast",m.keyword,"bitcast"),block:new Te("block",m.keyword,"block"),break:new Te("break",m.keyword,"break"),case:new Te("case",m.keyword,"case"),continue:new Te("continue",m.keyword,"continue"),continuing:new Te("continuing",m.keyword,"continuing"),default:new Te("default",m.keyword,"default"),discard:new Te("discard",m.keyword,"discard"),else:new Te("else",m.keyword,"else"),enable:new Te("enable",m.keyword,"enable"),fallthrough:new Te("fallthrough",m.keyword,"fallthrough"),false:new Te("false",m.keyword,"false"),fn:new Te("fn",m.keyword,"fn"),for:new Te("for",m.keyword,"for"),function:new Te("function",m.keyword,"function"),if:new Te("if",m.keyword,"if"),let:new Te("let",m.keyword,"let"),const:new Te("const",m.keyword,"const"),loop:new Te("loop",m.keyword,"loop"),while:new Te("while",m.keyword,"while"),private:new Te("private",m.keyword,"private"),read:new Te("read",m.keyword,"read"),read_write:new Te("read_write",m.keyword,"read_write"),return:new Te("return",m.keyword,"return"),storage:new Te("storage",m.keyword,"storage"),switch:new Te("switch",m.keyword,"switch"),true:new Te("true",m.keyword,"true"),alias:new Te("alias",m.keyword,"alias"),type:new Te("type",m.keyword,"type"),uniform:new Te("uniform",m.keyword,"uniform"),var:new Te("var",m.keyword,"var"),override:new Te("override",m.keyword,"override"),workgroup:new Te("workgroup",m.keyword,"workgroup"),write:new Te("write",m.keyword,"write"),r8unorm:new Te("r8unorm",m.keyword,"r8unorm"),r8snorm:new Te("r8snorm",m.keyword,"r8snorm"),r8uint:new Te("r8uint",m.keyword,"r8uint"),r8sint:new Te("r8sint",m.keyword,"r8sint"),r16uint:new Te("r16uint",m.keyword,"r16uint"),r16sint:new Te("r16sint",m.keyword,"r16sint"),r16float:new Te("r16float",m.keyword,"r16float"),rg8unorm:new Te("rg8unorm",m.keyword,"rg8unorm"),rg8snorm:new Te("rg8snorm",m.keyword,"rg8snorm"),rg8uint:new Te("rg8uint",m.keyword,"rg8uint"),rg8sint:new Te("rg8sint",m.keyword,"rg8sint"),r32uint:new Te("r32uint",m.keyword,"r32uint"),r32sint:new Te("r32sint",m.keyword,"r32sint"),r32float:new Te("r32float",m.keyword,"r32float"),rg16uint:new Te("rg16uint",m.keyword,"rg16uint"),rg16sint:new Te("rg16sint",m.keyword,"rg16sint"),rg16float:new Te("rg16float",m.keyword,"rg16float"),rgba8unorm:new Te("rgba8unorm",m.keyword,"rgba8unorm"),rgba8unorm_srgb:new Te("rgba8unorm_srgb",m.keyword,"rgba8unorm_srgb"),rgba8snorm:new Te("rgba8snorm",m.keyword,"rgba8snorm"),rgba8uint:new Te("rgba8uint",m.keyword,"rgba8uint"),rgba8sint:new Te("rgba8sint",m.keyword,"rgba8sint"),bgra8unorm:new Te("bgra8unorm",m.keyword,"bgra8unorm"),bgra8unorm_srgb:new Te("bgra8unorm_srgb",m.keyword,"bgra8unorm_srgb"),rgb10a2unorm:new Te("rgb10a2unorm",m.keyword,"rgb10a2unorm"),rg11b10float:new Te("rg11b10float",m.keyword,"rg11b10float"),rg32uint:new Te("rg32uint",m.keyword,"rg32uint"),rg32sint:new Te("rg32sint",m.keyword,"rg32sint"),rg32float:new Te("rg32float",m.keyword,"rg32float"),rgba16uint:new Te("rgba16uint",m.keyword,"rgba16uint"),rgba16sint:new Te("rgba16sint",m.keyword,"rgba16sint"),rgba16float:new Te("rgba16float",m.keyword,"rgba16float"),rgba32uint:new Te("rgba32uint",m.keyword,"rgba32uint"),rgba32sint:new Te("rgba32sint",m.keyword,"rgba32sint"),rgba32float:new Te("rgba32float",m.keyword,"rgba32float"),static_assert:new Te("static_assert",m.keyword,"static_assert")},Se.tokens={decimal_float_literal:new Te("decimal_float_literal",m.token,/((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?f?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+f?)|([0-9]+f)/),hex_float_literal:new Te("hex_float_literal",m.token,/-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+f?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+f?))/),int_literal:new Te("int_literal",m.token,/-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),uint_literal:new Te("uint_literal",m.token,/0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),ident:new Te("ident",m.token,/[a-zA-Z][0-9a-zA-Z_]*/),and:new Te("and",m.token,"&"),and_and:new Te("and_and",m.token,"&&"),arrow:new Te("arrow ",m.token,"->"),attr:new Te("attr",m.token,"@"),attr_left:new Te("attr_left",m.token,"[["),attr_right:new Te("attr_right",m.token,"]]"),forward_slash:new Te("forward_slash",m.token,"/"),bang:new Te("bang",m.token,"!"),bracket_left:new Te("bracket_left",m.token,"["),bracket_right:new Te("bracket_right",m.token,"]"),brace_left:new Te("brace_left",m.token,"{"),brace_right:new Te("brace_right",m.token,"}"),colon:new Te("colon",m.token,":"),comma:new Te("comma",m.token,","),equal:new Te("equal",m.token,"="),equal_equal:new Te("equal_equal",m.token,"=="),not_equal:new Te("not_equal",m.token,"!="),greater_than:new Te("greater_than",m.token,">"),greater_than_equal:new Te("greater_than_equal",m.token,">="),shift_right:new Te("shift_right",m.token,">>"),less_than:new Te("less_than",m.token,"<"),less_than_equal:new Te("less_than_equal",m.token,"<="),shift_left:new Te("shift_left",m.token,"<<"),modulo:new Te("modulo",m.token,"%"),minus:new Te("minus",m.token,"-"),minus_minus:new Te("minus_minus",m.token,"--"),period:new Te("period",m.token,"."),plus:new Te("plus",m.token,"+"),plus_plus:new Te("plus_plus",m.token,"++"),or:new Te("or",m.token,"|"),or_or:new Te("or_or",m.token,"||"),paren_left:new Te("paren_left",m.token,"("),paren_right:new Te("paren_right",m.token,")"),semicolon:new Te("semicolon",m.token,";"),star:new Te("star",m.token,"*"),tilde:new Te("tilde",m.token,"~"),underscore:new Te("underscore",m.token,"_"),xor:new Te("xor",m.token,"^"),plus_equal:new Te("plus_equal",m.token,"+="),minus_equal:new Te("minus_equal",m.token,"-="),times_equal:new Te("times_equal",m.token,"*="),division_equal:new Te("division_equal",m.token,"/="),modulo_equal:new Te("modulo_equal",m.token,"%="),and_equal:new Te("and_equal",m.token,"&="),or_equal:new Te("or_equal",m.token,"|="),xor_equal:new Te("xor_equal",m.token,"^="),shift_right_equal:new Te("shift_right_equal",m.token,">>="),shift_left_equal:new Te("shift_left_equal",m.token,"<<=")},Se.storage_class=[_.keywords.function,_.keywords.private,_.keywords.workgroup,_.keywords.uniform,_.keywords.storage],Se.access_mode=[_.keywords.read,_.keywords.write,_.keywords.read_write],Se.sampler_type=[_.keywords.sampler,_.keywords.sampler_comparison],Se.sampled_texture_type=[_.keywords.texture_1d,_.keywords.texture_2d,_.keywords.texture_2d_array,_.keywords.texture_3d,_.keywords.texture_cube,_.keywords.texture_cube_array],Se.multisampled_texture_type=[_.keywords.texture_multisampled_2d],Se.storage_texture_type=[_.keywords.texture_storage_1d,_.keywords.texture_storage_2d,_.keywords.texture_storage_2d_array,_.keywords.texture_storage_3d],Se.depth_texture_type=[_.keywords.texture_depth_2d,_.keywords.texture_depth_2d_array,_.keywords.texture_depth_cube,_.keywords.texture_depth_cube_array,_.keywords.texture_depth_multisampled_2d],Se.texture_external_type=[_.keywords.texture_external],Se.any_texture_type=[..._.sampled_texture_type,..._.multisampled_texture_type,..._.storage_texture_type,..._.depth_texture_type,..._.texture_external_type],Se.texel_format=[_.keywords.r8unorm,_.keywords.r8snorm,_.keywords.r8uint,_.keywords.r8sint,_.keywords.r16uint,_.keywords.r16sint,_.keywords.r16float,_.keywords.rg8unorm,_.keywords.rg8snorm,_.keywords.rg8uint,_.keywords.rg8sint,_.keywords.r32uint,_.keywords.r32sint,_.keywords.r32float,_.keywords.rg16uint,_.keywords.rg16sint,_.keywords.rg16float,_.keywords.rgba8unorm,_.keywords.rgba8unorm_srgb,_.keywords.rgba8snorm,_.keywords.rgba8uint,_.keywords.rgba8sint,_.keywords.bgra8unorm,_.keywords.bgra8unorm_srgb,_.keywords.rgb10a2unorm,_.keywords.rg11b10float,_.keywords.rg32uint,_.keywords.rg32sint,_.keywords.rg32float,_.keywords.rgba16uint,_.keywords.rgba16sint,_.keywords.rgba16float,_.keywords.rgba32uint,_.keywords.rgba32sint,_.keywords.rgba32float],Se.const_literal=[_.tokens.int_literal,_.tokens.uint_literal,_.tokens.decimal_float_literal,_.tokens.hex_float_literal,_.keywords.true,_.keywords.false],Se.literal_or_ident=[_.tokens.ident,_.tokens.int_literal,_.tokens.uint_literal,_.tokens.decimal_float_literal,_.tokens.hex_float_literal],Se.element_count_expression=[_.tokens.int_literal,_.tokens.uint_literal,_.tokens.ident],Se.template_types=[_.keywords.vec2,_.keywords.vec3,_.keywords.vec4,_.keywords.mat2x2,_.keywords.mat2x3,_.keywords.mat2x4,_.keywords.mat3x2,_.keywords.mat3x3,_.keywords.mat3x4,_.keywords.mat4x2,_.keywords.mat4x3,_.keywords.mat4x4,_.keywords.atomic,_.keywords.bitcast,..._.any_texture_type],Se.attribute_name=[_.tokens.ident,_.keywords.block],Se.assignment_operators=[_.tokens.equal,_.tokens.plus_equal,_.tokens.minus_equal,_.tokens.times_equal,_.tokens.division_equal,_.tokens.modulo_equal,_.tokens.and_equal,_.tokens.or_equal,_.tokens.xor_equal,_.tokens.shift_right_equal,_.tokens.shift_left_equal],Se.increment_operators=[_.tokens.plus_plus,_.tokens.minus_minus];class Ee{constructor(e,t,n){this.type=e,this.lexeme=t,this.line=n}toString(){return this.lexeme}isTemplateType(){return-1!=Se.template_types.indexOf(this.type)}isArrayType(){return this.type==Se.keywords.array}isArrayOrTemplateType(){return this.isArrayType()||this.isTemplateType()}}class Ae{constructor(e){this._tokens=[],this._start=0,this._current=0,this._line=1,this._source=null!=e?e:""}scanTokens(){for(;!this._isAtEnd();)if(this._start=this._current,!this.scanToken())throw`Invalid syntax at line ${this._line}`;return this._tokens.push(new Ee(Se.eof,"",this._line)),this._tokens}scanToken(){let e=this._advance();if("\n"==e)return this._line++,!0;if(this._isWhitespace(e))return!0;if("/"==e){if("/"==this._peekAhead()){for(;"\n"!=e;){if(this._isAtEnd())return!0;e=this._advance()}return this._line++,!0}if("*"==this._peekAhead()){this._advance();let t=1;for(;t>0;){if(this._isAtEnd())return!0;if(e=this._advance(),"\n"==e)this._line++;else if("*"==e){if("/"==this._peekAhead()&&(this._advance(),t--,0==t))return!0}else"/"==e&&"*"==this._peekAhead()&&(this._advance(),t++)}return!0}}let t=Se.none;for(;;){let n=this._findType(e);const r=this._peekAhead();if(">"==e&&(">"==r||"="==r)){let e=!1,t=this._tokens.length-1;for(let n=0;n<5&&t>=0;++n,--t)if(this._tokens[t].type===Se.tokens.less_than){t>0&&this._tokens[t-1].isArrayOrTemplateType()&&(e=!0);break}if(e)return this._addToken(n),!0}if(n===Se.none){let r=e,s=0;const i=2;for(let e=0;e<i;++e)if(r+=this._peekAhead(e),n=this._findType(r),n!==Se.none){s=e;break}if(n===Se.none)return t!==Se.none&&(this._current--,this._addToken(t),!0);e=r,this._current+=s+1}if(t=n,this._isAtEnd())break;e+=this._advance()}return t!==Se.none&&(this._addToken(t),!0)}_findType(e){for(const t in Se.keywords){const n=Se.keywords[t];if(this._match(e,n.rule))return n}for(const t in Se.tokens){const n=Se.tokens[t];if(this._match(e,n.rule))return n}return Se.none}_match(e,t){if("string"==typeof t){if(t==e)return!0}else{const n=t.exec(e);if(n&&0==n.index&&n[0]==e)return!0}return!1}_isAtEnd(){return this._current>=this._source.length}_isWhitespace(e){return" "==e||"\t"==e||"\r"==e}_advance(e=0){let t=this._source[this._current];return e=e||0,e++,this._current+=e,t}_peekAhead(e=0){return e=e||0,this._current+e>=this._source.length?"\0":this._source[this._current+e]}_addToken(e){const t=this._source.substring(this._start,this._current);this._tokens.push(new Ee(e,t,this._line))}}class ze{constructor(){this._tokens=[],this._current=0,this._context=new E}parse(e){this._initialize(e);let t=[];for(;!this._isAtEnd();){const e=this._global_decl_or_directive();if(!e)break;t.push(e)}return t}_initialize(e){if(e)if("string"==typeof e){const t=new Ae(e);this._tokens=t.scanTokens()}else this._tokens=e;else this._tokens=[];this._current=0}_error(e,t){return console.error(e,t),{token:e,message:t,toString:function(){return`${t}`}}}_isAtEnd(){return this._current>=this._tokens.length||this._peek().type==Se.eof}_match(e){if(e instanceof Te)return!!this._check(e)&&(this._advance(),!0);for(let t=0,n=e.length;t<n;++t){const n=e[t];if(this._check(n))return this._advance(),!0}return!1}_consume(e,t){if(this._check(e))return this._advance();throw this._error(this._peek(),t)}_check(e){if(this._isAtEnd())return!1;const t=this._peek();if(e instanceof Array){let n=t.type;return-1!=e.indexOf(n)}return t.type==e}_advance(){return this._isAtEnd()||this._current++,this._previous()}_peek(){return this._tokens[this._current]}_previous(){return this._tokens[this._current-1]}_global_decl_or_directive(){for(;this._match(Se.tokens.semicolon)&&!this._isAtEnd(););if(this._match(Se.keywords.alias)){const e=this._type_alias();return this._consume(Se.tokens.semicolon,"Expected ';'"),e}if(this._match(Se.keywords.enable)){const e=this._enable_directive();return this._consume(Se.tokens.semicolon,"Expected ';'"),e}const e=this._attribute();if(this._check(Se.keywords.var)){const t=this._global_variable_decl();return null!=t&&(t.attributes=e),this._consume(Se.tokens.semicolon,"Expected ';'."),t}if(this._check(Se.keywords.override)){const t=this._override_variable_decl();return null!=t&&(t.attributes=e),this._consume(Se.tokens.semicolon,"Expected ';'."),t}if(this._check(Se.keywords.let)){const t=this._global_let_decl();return null!=t&&(t.attributes=e),this._consume(Se.tokens.semicolon,"Expected ';'."),t}if(this._check(Se.keywords.const)){const t=this._global_const_decl();return null!=t&&(t.attributes=e),this._consume(Se.tokens.semicolon,"Expected ';'."),t}if(this._check(Se.keywords.struct)){const t=this._struct_decl();return null!=t&&(t.attributes=e),t}if(this._check(Se.keywords.fn)){const t=this._function_decl();return null!=t&&(t.attributes=e),t}return null}_function_decl(){if(!this._match(Se.keywords.fn))return null;const e=this._consume(Se.tokens.ident,"Expected function name.").toString();this._consume(Se.tokens.paren_left,"Expected '(' for function arguments.");const t=[];if(!this._check(Se.tokens.paren_right))do{if(this._check(Se.tokens.paren_right))break;const e=this._attribute(),n=this._consume(Se.tokens.ident,"Expected argument name.").toString();this._consume(Se.tokens.colon,"Expected ':' for argument type.");const r=this._attribute(),s=this._type_decl();null!=s&&(s.attributes=r,t.push(new ve(n,s,e)))}while(this._match(Se.tokens.comma));this._consume(Se.tokens.paren_right,"Expected ')' after function arguments.");let n=null;if(this._match(Se.tokens.arrow)){const e=this._attribute();n=this._type_decl(),null!=n&&(n.attributes=e)}const r=this._compound_statement();return new P(e,t,n,r)}_compound_statement(){const e=[];for(this._consume(Se.tokens.brace_left,"Expected '{' for block.");!this._check(Se.tokens.brace_right);){const t=this._statement();null!==t&&e.push(t)}return this._consume(Se.tokens.brace_right,"Expected '}' for block."),e}_statement(){for(;this._match(Se.tokens.semicolon)&&!this._isAtEnd(););if(this._check(Se.keywords.if))return this._if_statement();if(this._check(Se.keywords.switch))return this._switch_statement();if(this._check(Se.keywords.loop))return this._loop_statement();if(this._check(Se.keywords.for))return this._for_statement();if(this._check(Se.keywords.while))return this._while_statement();if(this._check(Se.keywords.continuing))return this._continuing_statement();if(this._check(Se.keywords.static_assert))return this._static_assert_statement();if(this._check(Se.tokens.brace_left))return this._compound_statement();let e=null;return e=this._check(Se.keywords.return)?this._return_statement():this._check([Se.keywords.var,Se.keywords.let,Se.keywords.const])?this._variable_statement():this._match(Se.keywords.discard)?new H:this._match(Se.keywords.break)?new K:this._match(Se.keywords.continue)?new Z:this._increment_decrement_statement()||this._func_call_statement()||this._assignment_statement(),null!=e&&this._consume(Se.tokens.semicolon,"Expected ';' after statement."),e}_static_assert_statement(){if(!this._match(Se.keywords.static_assert))return null;let e=this._optional_paren_expression();return new U(e)}_while_statement(){if(!this._match(Se.keywords.while))return null;let e=this._optional_paren_expression();const t=this._compound_statement();return new B(e,t)}_continuing_statement(){if(!this._match(Se.keywords.continuing))return null;const e=this._compound_statement();return new V(e)}_for_statement(){if(!this._match(Se.keywords.for))return null;this._consume(Se.tokens.paren_left,"Expected '('.");const e=this._check(Se.tokens.semicolon)?null:this._for_init();this._consume(Se.tokens.semicolon,"Expected ';'.");const t=this._check(Se.tokens.semicolon)?null:this._short_circuit_or_expression();this._consume(Se.tokens.semicolon,"Expected ';'.");const n=this._check(Se.tokens.paren_right)?null:this._for_increment();this._consume(Se.tokens.paren_right,"Expected ')'.");const r=this._compound_statement();return new G(e,t,n,r)}_for_init(){return this._variable_statement()||this._func_call_statement()||this._assignment_statement()}_for_increment(){return this._func_call_statement()||this._increment_decrement_statement()||this._assignment_statement()}_variable_statement(){if(this._check(Se.keywords.var)){const e=this._variable_decl();if(null===e)throw this._error(this._peek(),"Variable declaration expected.");let t=null;return this._match(Se.tokens.equal)&&(t=this._short_circuit_or_expression()),new N(e.name,e.type,e.storage,e.access,t)}if(this._match(Se.keywords.let)){const e=this._consume(Se.tokens.ident,"Expected name for let.").toString();let t=null;if(this._match(Se.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}this._consume(Se.tokens.equal,"Expected '=' for let.");const n=this._short_circuit_or_expression();return new q(e,t,null,null,n)}if(this._match(Se.keywords.const)){const e=this._consume(Se.tokens.ident,"Expected name for const.").toString();let t=null;if(this._match(Se.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}this._consume(Se.tokens.equal,"Expected '=' for const.");const n=this._short_circuit_or_expression();return new D(e,t,null,null,n)}return null}_increment_decrement_statement(){const e=this._current,t=this._unary_expression();if(null==t)return null;if(!this._check(Se.increment_operators))return this._current=e,null;const n=this._consume(Se.increment_operators,"Expected increment operator");return new R(n.type===Se.tokens.plus_plus?h.increment:h.decrement,t)}_assignment_statement(){let e=null;if(this._check(Se.tokens.brace_right))return null;let t=this._match(Se.tokens.underscore);if(t||(e=this._unary_expression()),!t&&null==e)return null;const n=this._consume(Se.assignment_operators,"Expected assignment operator."),r=this._short_circuit_or_expression();return new F(p.parse(n.lexeme),e,r)}_func_call_statement(){if(!this._check(Se.tokens.ident))return null;const e=this._current,t=this._consume(Se.tokens.ident,"Expected function name."),n=this._argument_expression_list();return null===n?(this._current=e,null):new L(t.lexeme,n)}_loop_statement(){if(!this._match(Se.keywords.loop))return null;this._consume(Se.tokens.brace_left,"Expected '{' for loop.");const e=[];let t=this._statement();for(;null!==t;){if(Array.isArray(t))for(let n of t)e.push(n);else e.push(t);t=this._statement()}let n=null;return this._match(Se.keywords.continuing)&&(n=this._compound_statement()),this._consume(Se.tokens.brace_right,"Expected '}' for loop."),new C(e,n)}_switch_statement(){if(!this._match(Se.keywords.switch))return null;const e=this._optional_paren_expression();this._consume(Se.tokens.brace_left,"Expected '{' for switch.");const t=this._switch_body();if(null==t||0==t.length)throw this._error(this._previous(),"Expected 'case' or 'default'.");return this._consume(Se.tokens.brace_right,"Expected '}' for switch."),new j(e,t)}_switch_body(){const e=[];if(this._match(Se.keywords.case)){const t=this._case_selectors();this._match(Se.tokens.colon),this._consume(Se.tokens.brace_left,"Exected '{' for switch case.");const n=this._case_body();this._consume(Se.tokens.brace_right,"Exected '}' for switch case."),e.push(new ye(t,n))}if(this._match(Se.keywords.default)){this._match(Se.tokens.colon),this._consume(Se.tokens.brace_left,"Exected '{' for switch default.");const t=this._case_body();this._consume(Se.tokens.brace_right,"Exected '}' for switch default."),e.push(new we(t))}if(this._check([Se.keywords.default,Se.keywords.case])){const t=this._switch_body();e.push(t[0])}return e}_case_selectors(){var e,t,n,r;const s=[null!==(t=null===(e=this._shift_expression())||void 0===e?void 0:e.evaluate(this._context).toString())&&void 0!==t?t:""];for(;this._match(Se.tokens.comma);)s.push(null!==(r=null===(n=this._shift_expression())||void 0===n?void 0:n.evaluate(this._context).toString())&&void 0!==r?r:"");return s}_case_body(){if(this._match(Se.keywords.fallthrough))return this._consume(Se.tokens.semicolon,"Expected ';'"),[];let e=this._statement();if(null==e)return[];e instanceof Array||(e=[e]);const t=this._case_body();return 0==t.length?e:[...e,t[0]]}_if_statement(){if(!this._match(Se.keywords.if))return null;const e=this._optional_paren_expression(),t=this._compound_statement();let n=[];this._match_elseif()&&(n=this._elseif_statement(n));let r=null;return this._match(Se.keywords.else)&&(r=this._compound_statement()),new $(e,t,n,r)}_match_elseif(){return this._tokens[this._current].type===Se.keywords.else&&this._tokens[this._current+1].type===Se.keywords.if&&(this._advance(),this._advance(),!0)}_elseif_statement(e=[]){const t=this._optional_paren_expression(),n=this._compound_statement();return e.push(new xe(t,n)),this._match_elseif()&&this._elseif_statement(e),e}_return_statement(){if(!this._match(Se.keywords.return))return null;const e=this._short_circuit_or_expression();return new Y(e)}_short_circuit_or_expression(){let e=this._short_circuit_and_expr();for(;this._match(Se.tokens.or_or);)e=new me(this._previous().toString(),e,this._short_circuit_and_expr());return e}_short_circuit_and_expr(){let e=this._inclusive_or_expression();for(;this._match(Se.tokens.and_and);)e=new me(this._previous().toString(),e,this._inclusive_or_expression());return e}_inclusive_or_expression(){let e=this._exclusive_or_expression();for(;this._match(Se.tokens.or);)e=new me(this._previous().toString(),e,this._exclusive_or_expression());return e}_exclusive_or_expression(){let e=this._and_expression();for(;this._match(Se.tokens.xor);)e=new me(this._previous().toString(),e,this._and_expression());return e}_and_expression(){let e=this._equality_expression();for(;this._match(Se.tokens.and);)e=new me(this._previous().toString(),e,this._equality_expression());return e}_equality_expression(){const e=this._relational_expression();return this._match([Se.tokens.equal_equal,Se.tokens.not_equal])?new me(this._previous().toString(),e,this._relational_expression()):e}_relational_expression(){let e=this._shift_expression();for(;this._match([Se.tokens.less_than,Se.tokens.greater_than,Se.tokens.less_than_equal,Se.tokens.greater_than_equal]);)e=new me(this._previous().toString(),e,this._shift_expression());return e}_shift_expression(){let e=this._additive_expression();for(;this._match([Se.tokens.shift_left,Se.tokens.shift_right]);)e=new me(this._previous().toString(),e,this._additive_expression());return e}_additive_expression(){let e=this._multiplicative_expression();for(;this._match([Se.tokens.plus,Se.tokens.minus]);)e=new me(this._previous().toString(),e,this._multiplicative_expression());return e}_multiplicative_expression(){let e=this._unary_expression();for(;this._match([Se.tokens.star,Se.tokens.forward_slash,Se.tokens.modulo]);)e=new me(this._previous().toString(),e,this._unary_expression());return e}_unary_expression(){return this._match([Se.tokens.minus,Se.tokens.bang,Se.tokens.tilde,Se.tokens.star,Se.tokens.and])?new _e(this._previous().toString(),this._unary_expression()):this._singular_expression()}_singular_expression(){const e=this._primary_expression(),t=this._postfix_expression();return t&&(e.postfix=t),e}_postfix_expression(){if(this._match(Se.tokens.bracket_left)){const e=this._short_circuit_or_expression();this._consume(Se.tokens.bracket_right,"Expected ']'.");const t=this._postfix_expression();return t&&(e.postfix=t),e}if(this._match(Se.tokens.period)){const e=this._consume(Se.tokens.ident,"Expected member name."),t=this._postfix_expression(),n=new ie(e.lexeme);return t&&(n.postfix=t),n}return null}_getStruct(e){if(this._context.aliases.has(e)){return this._context.aliases.get(e).type}if(this._context.structs.has(e)){return this._context.structs.get(e)}return null}_primary_expression(){if(this._match(Se.tokens.ident)){const e=this._previous().toString();if(this._check(Se.tokens.paren_left)){const t=this._argument_expression_list(),n=this._getStruct(e);return null!=n?new oe(n,t):new ae(e,t)}if(this._context.constants.has(e)){const t=this._context.constants.get(e);return new ce(e,t.value)}return new ue(e)}if(this._match(Se.const_literal))return new le(parseFloat(this._previous().toString()));if(this._check(Se.tokens.paren_left))return this._paren_expression();if(this._match(Se.keywords.bitcast)){this._consume(Se.tokens.less_than,"Expected '<'.");const e=this._type_decl();this._consume(Se.tokens.greater_than,"Expected '>'.");const t=this._paren_expression();return new he(e,t)}const e=this._type_decl(),t=this._argument_expression_list();return new fe(e,t)}_argument_expression_list(){if(!this._match(Se.tokens.paren_left))return null;const e=[];do{if(this._check(Se.tokens.paren_right))break;const t=this._short_circuit_or_expression();e.push(t)}while(this._match(Se.tokens.comma));return this._consume(Se.tokens.paren_right,"Expected ')' for agument list"),e}_optional_paren_expression(){this._match(Se.tokens.paren_left);const e=this._short_circuit_or_expression();return this._match(Se.tokens.paren_right),new pe([e])}_paren_expression(){this._consume(Se.tokens.paren_left,"Expected '('.");const e=this._short_circuit_or_expression();return this._consume(Se.tokens.paren_right,"Expected ')'."),new pe([e])}_struct_decl(){if(!this._match(Se.keywords.struct))return null;const e=this._consume(Se.tokens.ident,"Expected name for struct.").toString();this._consume(Se.tokens.brace_left,"Expected '{' for struct body.");const t=[];for(;!this._check(Se.tokens.brace_right);){const e=this._attribute(),n=this._consume(Se.tokens.ident,"Expected variable name.").toString();this._consume(Se.tokens.colon,"Expected ':' for struct member type.");const r=this._attribute(),s=this._type_decl();null!=s&&(s.attributes=r),this._check(Se.tokens.brace_right)?this._match(Se.tokens.comma):this._consume(Se.tokens.comma,"Expected ',' for struct member."),t.push(new ke(n,s,e))}this._consume(Se.tokens.brace_right,"Expected '}' after struct body.");const n=new Q(e,t);return this._context.structs.set(e,n),n}_global_variable_decl(){const e=this._variable_decl();return e&&this._match(Se.tokens.equal)&&(e.value=this._const_expression()),e}_override_variable_decl(){const e=this._override_decl();return e&&this._match(Se.tokens.equal)&&(e.value=this._const_expression()),e}_global_const_decl(){if(!this._match(Se.keywords.const))return null;const e=this._consume(Se.tokens.ident,"Expected variable name");let t=null;if(this._match(Se.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}let n=null;if(this._match(Se.tokens.equal)){const e=this._short_circuit_or_expression();if(e instanceof oe)n=e;else if(e instanceof ce&&e.initializer instanceof oe)n=e.initializer;else try{const t=e.evaluate(this._context);n=new le(t)}catch(s){n=e}}const r=new D(e.toString(),t,"","",n);return this._context.constants.set(r.name,r),r}_global_let_decl(){if(!this._match(Se.keywords.let))return null;const e=this._consume(Se.tokens.ident,"Expected variable name");let t=null;if(this._match(Se.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}let n=null;return this._match(Se.tokens.equal)&&(n=this._const_expression()),new q(e.toString(),t,"","",n)}_const_expression(){if(this._match(Se.const_literal))return new ie(this._previous().toString());const e=this._type_decl();this._consume(Se.tokens.paren_left,"Expected '('.");let t=[];for(;!this._check(Se.tokens.paren_right)&&(t.push(this._const_expression()),this._check(Se.tokens.comma));)this._advance();return this._consume(Se.tokens.paren_right,"Expected ')'."),new oe(e,t)}_variable_decl(){if(!this._match(Se.keywords.var))return null;let e="",t="";this._match(Se.tokens.less_than)&&(e=this._consume(Se.storage_class,"Expected storage_class.").toString(),this._match(Se.tokens.comma)&&(t=this._consume(Se.access_mode,"Expected access_mode.").toString()),this._consume(Se.tokens.greater_than,"Expected '>'."));const n=this._consume(Se.tokens.ident,"Expected variable name");let r=null;if(this._match(Se.tokens.colon)){const e=this._attribute();r=this._type_decl(),null!=r&&(r.attributes=e)}return new N(n.toString(),r,e,t,null)}_override_decl(){if(!this._match(Se.keywords.override))return null;const e=this._consume(Se.tokens.ident,"Expected variable name");let t=null;if(this._match(Se.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}return new O(e.toString(),t,null)}_enable_directive(){const e=this._consume(Se.tokens.ident,"identity expected.");return new W(e.toString())}_type_alias(){const e=this._consume(Se.tokens.ident,"identity expected.");this._consume(Se.tokens.equal,"Expected '=' for type alias.");let t=this._type_decl();if(null===t)throw this._error(this._peek(),"Expected Type for Alias.");this._context.aliases.has(t.name)&&(t=this._context.aliases.get(t.name).type);const n=new X(e.toString(),t);return this._context.aliases.set(n.name,n),n}_type_decl(){if(this._check([Se.tokens.ident,...Se.texel_format,Se.keywords.bool,Se.keywords.f32,Se.keywords.i32,Se.keywords.u32])){const e=this._advance(),t=e.toString();return this._context.structs.has(t)?this._context.structs.get(t):this._context.aliases.has(t)?this._context.aliases.get(t).type:new J(e.toString())}let e=this._texture_sampler_types();if(e)return e;if(this._check(Se.template_types)){let e=this._advance().toString(),t=null,n=null;return this._match(Se.tokens.less_than)&&(t=this._type_decl(),n=null,this._match(Se.tokens.comma)&&(n=this._consume(Se.access_mode,"Expected access_mode for pointer").toString()),this._consume(Se.tokens.greater_than,"Expected '>' for type.")),new ee(e,t,n)}if(this._match(Se.keywords.ptr)){let e=this._previous().toString();this._consume(Se.tokens.less_than,"Expected '<' for pointer.");const t=this._consume(Se.storage_class,"Expected storage_class for pointer");this._consume(Se.tokens.comma,"Expected ',' for pointer.");const n=this._type_decl();let r=null;return this._match(Se.tokens.comma)&&(r=this._consume(Se.access_mode,"Expected access_mode for pointer").toString()),this._consume(Se.tokens.greater_than,"Expected '>' for pointer."),new te(e,t.toString(),n,r)}const t=this._attribute();if(this._match(Se.keywords.array)){let e=null,n=-1;const r=this._previous();if(this._match(Se.tokens.less_than)){e=this._type_decl(),this._context.aliases.has(e.name)&&(e=this._context.aliases.get(e.name).type);let t="";if(this._match(Se.tokens.comma)){t=this._shift_expression().evaluate(this._context).toString()}this._consume(Se.tokens.greater_than,"Expected '>' for array."),n=t?parseInt(t):0}return new ne(r.toString(),t,e,n)}return null}_texture_sampler_types(){if(this._match(Se.sampler_type))return new re(this._previous().toString(),null,null);if(this._match(Se.depth_texture_type))return new re(this._previous().toString(),null,null);if(this._match(Se.sampled_texture_type)||this._match(Se.multisampled_texture_type)){const e=this._previous();this._consume(Se.tokens.less_than,"Expected '<' for sampler type.");const t=this._type_decl();return this._consume(Se.tokens.greater_than,"Expected '>' for sampler type."),new re(e.toString(),t,null)}if(this._match(Se.storage_texture_type)){const e=this._previous();this._consume(Se.tokens.less_than,"Expected '<' for sampler type.");const t=this._consume(Se.texel_format,"Invalid texel format.").toString();this._consume(Se.tokens.comma,"Expected ',' after texel format.");const n=this._consume(Se.access_mode,"Expected access mode for storage texture type.").toString();return this._consume(Se.tokens.greater_than,"Expected '>' for sampler type."),new re(e.toString(),t,n)}return null}_attribute(){let e=[];for(;this._match(Se.tokens.attr);){const t=this._consume(Se.attribute_name,"Expected attribute name"),n=new be(t.toString(),null);if(this._match(Se.tokens.paren_left)){if(n.value=this._consume(Se.literal_or_ident,"Expected attribute value").toString(),this._check(Se.tokens.comma)){this._advance();do{const e=this._consume(Se.literal_or_ident,"Expected attribute value").toString();n.value instanceof Array||(n.value=[n.value]),n.value.push(e)}while(this._match(Se.tokens.comma))}this._consume(Se.tokens.paren_right,"Expected ')'")}e.push(n)}for(;this._match(Se.tokens.attr_left);){if(!this._check(Se.tokens.attr_right))do{const t=this._consume(Se.attribute_name,"Expected attribute name"),n=new be(t.toString(),null);if(this._match(Se.tokens.paren_left)){if(n.value=[this._consume(Se.literal_or_ident,"Expected attribute value").toString()],this._check(Se.tokens.comma)){this._advance();do{const e=this._consume(Se.literal_or_ident,"Expected attribute value").toString();n.value.push(e)}while(this._match(Se.tokens.comma))}this._consume(Se.tokens.paren_right,"Expected ')'")}e.push(n)}while(this._match(Se.tokens.comma));this._consume(Se.tokens.attr_right,"Expected ']]' after attribute declarations")}return 0==e.length?null:e}}class Ie{constructor(e,t){this.name=e,this.attributes=t,this.size=0}get isArray(){return!1}get isStruct(){return!1}get isTemplate(){return!1}}class Me{constructor(e,t,n){this.name=e,this.type=t,this.attributes=n,this.offset=0,this.size=0}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class Pe extends Ie{constructor(e,t){super(e,t),this.members=[],this.align=0}get isStruct(){return!0}}class Ue extends Ie{constructor(e,t){super(e,t),this.count=0,this.stride=0}get isArray(){return!0}}class Be extends Ie{constructor(e,t,n,r){super(e,n),this.format=t,this.access=r}get isTemplate(){return!0}}(w=y||(y={}))[w.Uniform=0]="Uniform",w[w.Storage=1]="Storage",w[w.Texture=2]="Texture",w[w.Sampler=3]="Sampler",w[w.StorageTexture=4]="StorageTexture";class Ve{constructor(e,t,n,r,s,i,o){this.name=e,this.type=t,this.group=n,this.binding=r,this.attributes=s,this.resourceType=i,this.access=o}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get size(){return this.type.size}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class Ge{constructor(e,t){this.name=e,this.type=t}}class Ne{constructor(e,t){this.align=e,this.size=t}}class Oe{constructor(e,t,n,r){this.name=e,this.type=t,this.locationType=n,this.location=r,this.interpolation=null}}class qe{constructor(e,t,n,r){this.name=e,this.type=t,this.locationType=n,this.location=r}}class De{constructor(e,t=null){this.stage=null,this.inputs=[],this.outputs=[],this.resources=[],this.name=e,this.stage=t}}class Re{constructor(){this.vertex=[],this.fragment=[],this.compute=[]}}class Fe{constructor(e,t,n,r){this.name=e,this.type=t,this.attributes=n,this.id=r}}class Le{constructor(e){this.resources=null,this.node=e}}class Ce{constructor(e){this.uniforms=[],this.storage=[],this.textures=[],this.samplers=[],this.aliases=[],this.overrides=[],this.structs=[],this.entry=new Re,this._types=new Map,this._functions=new Map,e&&this.update(e)}_isStorageTexture(e){return"texture_storage_1d"==e.name||"texture_storage_2d"==e.name||"texture_storage_2d_array"==e.name||"texture_storage_3d"==e.name}update(e){const t=(new ze).parse(e);for(const n of t)n instanceof P&&this._functions.set(n.name,new Le(n));for(const n of t)if(n instanceof Q){const e=this._getTypeInfo(n,null);e instanceof Pe&&this.structs.push(e)}else if(n instanceof X)this.aliases.push(this._getAliasInfo(n));else if(n instanceof O){const e=n,t=this._getAttributeNum(e.attributes,"id",0),r=null!=e.type?this._getTypeInfo(e.type,e.attributes):null;this.overrides.push(new Fe(e.name,r,e.attributes,t))}else if(this._isUniformVar(n)){const e=n,t=this._getAttributeNum(e.attributes,"group",0),r=this._getAttributeNum(e.attributes,"binding",0),s=this._getTypeInfo(e.type,e.attributes),i=new Ve(e.name,s,t,r,e.attributes,y.Uniform,e.access);this.uniforms.push(i)}else if(this._isStorageVar(n)){const e=n,t=this._getAttributeNum(e.attributes,"group",0),r=this._getAttributeNum(e.attributes,"binding",0),s=this._getTypeInfo(e.type,e.attributes),i=this._isStorageTexture(s),o=new Ve(e.name,s,t,r,e.attributes,i?y.StorageTexture:y.Storage,e.access);this.storage.push(o)}else if(this._isTextureVar(n)){const e=n,t=this._getAttributeNum(e.attributes,"group",0),r=this._getAttributeNum(e.attributes,"binding",0),s=this._getTypeInfo(e.type,e.attributes),i=this._isStorageTexture(s),o=new Ve(e.name,s,t,r,e.attributes,i?y.StorageTexture:y.Texture,e.access);i?this.storage.push(o):this.textures.push(o)}else if(this._isSamplerVar(n)){const e=n,t=this._getAttributeNum(e.attributes,"group",0),r=this._getAttributeNum(e.attributes,"binding",0),s=this._getTypeInfo(e.type,e.attributes),i=new Ve(e.name,s,t,r,e.attributes,y.Sampler,e.access);this.samplers.push(i)}else if(n instanceof P){const e=this._getAttribute(n,"vertex"),t=this._getAttribute(n,"fragment"),r=this._getAttribute(n,"compute"),s=e||t||r;if(s){const e=new De(n.name,null==s?void 0:s.name);e.inputs=this._getInputs(n.args),e.outputs=this._getOutputs(n.returnType),e.resources=this._findResources(n),this.entry[s.name].push(e)}}else;}_findResource(e){for(const t of this.uniforms)if(t.name==e)return t;for(const t of this.storage)if(t.name==e)return t;for(const t of this.textures)if(t.name==e)return t;for(const t of this.samplers)if(t.name==e)return t;return null}_findResources(e){const t=[],n=this,r=[];return e.search((e=>{if(e instanceof z)r.push({});else if(e instanceof I)r.pop();else if(e instanceof N){if(r.length>0){const t=e;r[r.length-1][t.name]=t}}else if(e instanceof q){if(r.length>0){const t=e;r[r.length-1][t.name]=t}}else if(e instanceof ue){const s=e;if(r.length>0){if(r[r.length-1][s.name])return}const i=n._findResource(s.name);i&&t.push(i)}else if(e instanceof ae){const r=e,s=n._functions.get(r.name);s&&(null===s.resources&&(s.resources=n._findResources(s.node)),t.push(...s.resources))}})),[...new Map(t.map((e=>[e.name,e]))).values()]}getBindGroups(){const e=[];function t(t,n){t>=e.length&&(e.length=t+1),void 0===e[t]&&(e[t]=[]),n>=e[t].length&&(e[t].length=n+1)}for(const n of this.uniforms){t(n.group,n.binding);e[n.group][n.binding]=n}for(const n of this.storage){t(n.group,n.binding);e[n.group][n.binding]=n}for(const n of this.textures){t(n.group,n.binding);e[n.group][n.binding]=n}for(const n of this.samplers){t(n.group,n.binding);e[n.group][n.binding]=n}return e}_getOutputs(e,t=void 0){if(void 0===t&&(t=[]),e instanceof Q)this._getStructOutputs(e,t);else{const n=this._getOutputInfo(e);null!==n&&t.push(n)}return t}_getStructOutputs(e,t){for(const n of e.members)if(n.type instanceof Q)this._getStructOutputs(n.type,t);else{const e=this._getAttribute(n,"location")||this._getAttribute(n,"builtin");if(null!==e){const r=this._getTypeInfo(n.type,n.type.attributes),s=this._parseInt(e.value),i=new qe(n.name,r,e.name,s);t.push(i)}}}_getOutputInfo(e){const t=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(null!==t){const n=this._getTypeInfo(e,e.attributes),r=this._parseInt(t.value);return new qe("",n,t.name,r)}return null}_getInputs(e,t=void 0){void 0===t&&(t=[]);for(const n of e)if(n.type instanceof Q)this._getStructInputs(n.type,t);else{const e=this._getInputInfo(n);null!==e&&t.push(e)}return t}_getStructInputs(e,t){for(const n of e.members)if(n.type instanceof Q)this._getStructInputs(n.type,t);else{const e=this._getInputInfo(n);null!==e&&t.push(e)}}_getInputInfo(e){const t=this._getAttribute(e,"location")||this._getAttribute(e,"builtin");if(null!==t){const n=this._getAttribute(e,"interpolation"),r=this._getTypeInfo(e.type,e.attributes),s=this._parseInt(t.value),i=new Oe(e.name,r,t.name,s);return null!==n&&(i.interpolation=this._parseString(n.value)),i}return null}_parseString(e){return e instanceof Array&&(e=e[0]),e}_parseInt(e){e instanceof Array&&(e=e[0]);const t=parseInt(e);return isNaN(t)?e:t}_getAlias(e){for(const t of this.aliases)if(t.name==e)return t.type;return null}_getAliasInfo(e){return new Ge(e.name,this._getTypeInfo(e.type,null))}_getTypeInfo(e,t){if(this._types.has(e))return this._types.get(e);if(e instanceof ne){const n=e,r=this._getTypeInfo(n.format,n.attributes),s=new Ue(n.name,t);return s.format=r,s.count=n.count,this._types.set(e,s),this._updateTypeInfo(s),s}if(e instanceof Q){const n=e,r=new Pe(n.name,t);for(const e of n.members){const t=this._getTypeInfo(e.type,e.attributes);r.members.push(new Me(e.name,t,e.attributes))}return this._types.set(e,r),this._updateTypeInfo(r),r}if(e instanceof re){const n=e,r=n.format instanceof J,s=n.format?r?this._getTypeInfo(n.format,null):new Ie(n.format,null):null,i=new Be(n.name,s,t,n.access);return this._types.set(e,i),this._updateTypeInfo(i),i}if(e instanceof ee){const n=e,r=n.format?this._getTypeInfo(n.format,null):null,s=new Be(n.name,r,t,n.access);return this._types.set(e,s),this._updateTypeInfo(s),s}const n=new Ie(e.name,t);return this._types.set(e,n),this._updateTypeInfo(n),n}_updateTypeInfo(e){var t,n;const r=this._getTypeSize(e);if(e.size=null!==(t=null==r?void 0:r.size)&&void 0!==t?t:0,e instanceof Ue){const t=this._getTypeSize(e.format);e.stride=null!==(n=null==t?void 0:t.size)&&void 0!==n?n:0,this._updateTypeInfo(e.format)}e instanceof Pe&&this._updateStructInfo(e)}_updateStructInfo(e){var t;let n=0,r=0,s=0,i=0;for(let o=0,a=e.members.length;o<a;++o){const a=e.members[o],u=this._getTypeSize(a);if(!u)continue;null!==(t=this._getAlias(a.type.name))&&void 0!==t||a.type;const c=u.align,l=u.size;n=this._roundUp(c,n+r),r=l,s=n,i=Math.max(i,c),a.offset=n,a.size=l,this._updateTypeInfo(a.type)}e.size=this._roundUp(i,s+r),e.align=i}_getTypeSize(e){var t;if(null==e)return null;const n=this._getAttributeNum(e.attributes,"size",0),r=this._getAttributeNum(e.attributes,"align",0);if(e instanceof Me&&(e=e.type),e instanceof Ie){const t=this._getAlias(e.name);null!==t&&(e=t)}{const t=Ce._typeInfo[e.name];if(void 0!==t){const s="f16"===e.format?2:1;return new Ne(Math.max(r,t.align/s),Math.max(n,t.size/s))}}{const t=Ce._typeInfo[e.name.substring(0,e.name.length-1)];if(t){const s="h"===e.name[e.name.length-1]?2:1;return new Ne(Math.max(r,t.align/s),Math.max(n,t.size/s))}}if(e instanceof Ue){let s=e,i=8,o=8;const a=this._getTypeSize(s.format);null!==a&&(o=a.size,i=a.align);return o=s.count*this._getAttributeNum(null!==(t=null==e?void 0:e.attributes)&&void 0!==t?t:null,"stride",this._roundUp(i,o)),n&&(o=n),new Ne(Math.max(r,i),Math.max(n,o))}if(e instanceof Pe){let t=0,s=0,i=0,o=0,a=0;for(const n of e.members){const e=this._getTypeSize(n.type);null!==e&&(t=Math.max(e.align,t),i=this._roundUp(e.align,i+o),o=e.size,a=i)}return s=this._roundUp(t,a+o),new Ne(Math.max(r,t),Math.max(n,s))}return null}_isUniformVar(e){return e instanceof N&&"uniform"==e.storage}_isStorageVar(e){return e instanceof N&&"storage"==e.storage}_isTextureVar(e){return e instanceof N&&null!==e.type&&-1!=Ce._textureTypes.indexOf(e.type.name)}_isSamplerVar(e){return e instanceof N&&null!==e.type&&-1!=Ce._samplerTypes.indexOf(e.type.name)}_getAttribute(e,t){const n=e;if(!n||!n.attributes)return null;const r=n.attributes;for(let s of r)if(s.name==t)return s;return null}_getAttributeNum(e,t,n){if(null===e)return n;for(let r of e)if(r.name==t){let e=null!==r&&null!==r.value?r.value:n;return e instanceof Array&&(e=e[0]),"number"==typeof e?e:"string"==typeof e?parseInt(e):n}return n}_roundUp(e,t){return Math.ceil(t/e)*e}}function je(e,t,n){if(!t)return[];const r=function(e,t,n){const{entryPoint:r}=t;if(r){const t=e.entryPoints[r];return t&&t.stage===n?t:void 0}return Object.values(e.entryPoints).filter((e=>e.stage===n))[0]}(e,t,n);return(null==r?void 0:r.resources)||[]}Ce._typeInfo={f16:{align:2,size:2},i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},atomic:{align:4,size:4},vec2:{align:8,size:8},vec3:{align:16,size:12},vec4:{align:16,size:16},mat2x2:{align:8,size:16},mat3x2:{align:8,size:24},mat4x2:{align:8,size:32},mat2x3:{align:16,size:32},mat3x3:{align:16,size:48},mat4x3:{align:16,size:64},mat2x4:{align:16,size:32},mat3x4:{align:16,size:48},mat4x4:{align:16,size:64}},Ce._textureTypes=Se.any_texture_type.map((e=>e.name)),Ce._samplerTypes=Se.sampler_type.map((e=>e.name));const $e=(e,t)=>Math.sign(e.binding-t.binding);function Ye(e,t){const n=[...je((e=Array.isArray(e)?e:[e])[0],t.vertex,GPUShaderStage.VERTEX),...je(e[e.length-1],t.fragment,GPUShaderStage.FRAGMENT),...je(e[0],t.compute,GPUShaderStage.COMPUTE)],r=[];for(const s of n){const e=r[s.group]||new Map;r[s.group]=e;const t=e.get(s.entry.binding);e.set(s.entry.binding,{...s.entry,visibility:s.entry.visibility|((null==t?void 0:t.visibility)||0)})}return r.map((e=>({entries:[...e.values()].sort($e)})))}function We(e,t){return Object.fromEntries(t.map((t=>{const n=rt(e,t.type,0);return[t.name,{typeDefinition:n,group:t.group,binding:t.binding,size:n.size}]})))}function Xe(e,t,n){return{fields:Object.fromEntries(t.members.map((t=>[t.name,{offset:t.offset,type:rt(e,t.type,0)}]))),size:t.size,offset:n}}function He(e){var t;if(e.name.includes("depth"))return"depth";switch(null==(t=e.format)?void 0:t.name){case"f32":return"float";case"i32":return"sint";case"u32":return"uint";default:throw new Error("unknown texture sample type")}}function Ke(e){return e.name.includes("2d_array")?"2d-array":e.name.includes("cube_array")?"cube-array":e.name.includes("3d")?"3d":e.name.includes("1d")?"1d":e.name.includes("cube")?"cube":"2d"}function Ze(e){switch(e.access){case"read":return"read-only";case"write":return"write-only";case"read_write":return"read-write";default:throw new Error("unknonw storage texture access")}}function Je(e){return e.name.endsWith("_comparison")?"comparison":"filtering"}function Qe(e,t){const{binding:n,access:r,type:s}=e;switch(e.resourceType){case y.Uniform:return{binding:n,visibility:t,buffer:{}};case y.Storage:return{binding:n,visibility:t,buffer:{type:""===r||"read"===r?"read-only-storage":"storage"}};case y.Texture:{if("texture_external"===s.name)return{binding:n,visibility:t,externalTexture:{}};const e=s.name.includes("multisampled");return{binding:n,visibility:t,texture:{sampleType:He(s),viewDimension:Ke(s),multisampled:e}}}case y.Sampler:return{binding:n,visibility:t,sampler:{type:Je(s)}};case y.StorageTexture:return{binding:n,visibility:t,storageTexture:{access:Ze(s),format:s.format.name,viewDimension:Ke(s)}};default:throw new Error("unknown resource type")}}function et(e,t){const n={};for(const r of e)n[r.name]={stage:t,resources:r.resources.map((e=>{const{name:n,group:r}=e;return{name:n,group:r,entry:Qe(e,t)}}))};return n}function tt(e){const t=new Ce(e),n=Object.fromEntries(t.structs.map((e=>[e.name,Xe(t,e,0)]))),r=We(t,t.uniforms);return{structs:n,storages:We(t,t.storage),uniforms:r,entryPoints:{...et(t.entry.vertex,GPUShaderStage.VERTEX),...et(t.entry.fragment,GPUShaderStage.FRAGMENT),...et(t.entry.compute,GPUShaderStage.COMPUTE)}}}function nt(e,t=""){if(!e)throw new Error(t)}function rt(e,t,n){if(t.isArray){nt(!t.isStruct,"struct array is invalid"),nt(!t.isStruct,"template array is invalid");const r=t;return{size:r.size,elementType:rt(e,r.format,n),numElements:r.count}}if(t.isStruct){nt(!t.isTemplate,"template struct is invalid");return Xe(e,t,n)}{const e=t,n=t.isTemplate?`${e.name}<${e.format.name}>`:t.name;return{size:t.size,type:n}}}const st=new Map([[Int8Array,{formats:["sint8","snorm8"],defaultForType:1}],[Uint8Array,{formats:["uint8","unorm8"],defaultForType:1}],[Int16Array,{formats:["sint16","snorm16"],defaultForType:1}],[Uint16Array,{formats:["uint16","unorm16"],defaultForType:1}],[Int32Array,{formats:["sint32","snorm32"],defaultForType:0}],[Uint32Array,{formats:["uint32","unorm32"],defaultForType:0}],[Float32Array,{formats:["float32","float32"],defaultForType:0}]]);new Map([...st.entries()].map((([e,{formats:[t,n]}])=>[[t,e],[n,e]])).flat());class it extends r{constructor(e,t,n){super(e),this.paint=t,this.reactionDiffusion=n;const r=Ye(tt(s),{fragment:{entryPoint:"frag_main"}}),i=e.device.createBindGroupLayout(r[0]);this.sampler=e.device.createSampler({minFilter:"linear",magFilter:"linear"}),this.renderPassDescriptorTemplate={label:"composite pass"},this.bindGroupLayouts=[i]}async init(){this.createBindGroups(),await super.init("composite pipeline",s,"frag_main",this.bindGroupLayouts,this.renderer.presentationFormat)}get renderPassDescriptor(){return{...this.renderPassDescriptorTemplate,colorAttachments:[this.renderer.colorAttachment]}}setSize(e,t){super.setSize(e,t),this.createBindGroups()}render(e){e.setBindGroup(0,this.bindGroup),super.render(e)}createBindGroups(){this.bindGroup=this.renderer.device.createBindGroup({layout:this.bindGroupLayouts[0],entries:[{binding:0,resource:this.sampler},{binding:1,resource:this.reactionDiffusion.resultStorageTexture.createView()},{binding:2,resource:this.paint.resultStorageTexture.createView()}]})}}const ot=[8,8],at=[3,3],ut=[at[0]*ot[0],at[1]*ot[1]],ct=[ut[0]-Math.max(0,2),ut[1]-Math.max(0,2)],lt=ct,ht=`\n\nconst kernelSize = 3;\nconst dispatchSize = vec2u(${ct[0]},${ct[1]});\nconst tileSize = vec2u(${at[0]},${at[1]});\n\n@group(0) @binding(0) var seedTex: texture_2d<f32>;\n@group(0) @binding(1) var inputTex: texture_2d<f32>;\n@group(0) @binding(2) var outputTex: texture_storage_2d<rgba16float, write>;\n\n// the cache for the texture lookups (tileSize * workgroupSize)\nvar<workgroup> cache: array<array<vec4f, ${ut[0]}>, ${ut[1]}>;\n\nfn map(value: f32, inMin: f32, inMax: f32, outMin: f32, outMax: f32) -> f32 {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nfn texture2D_bilinear(t: texture_2d<f32>, uv: vec2f, dims: vec2u) -> vec4f {\n    let sample: vec2u = vec2u(uv);\n    let tl: vec4f = textureLoad(t, clamp(sample, vec2u(1, 1), dims), 0);\n    let tr: vec4f = textureLoad(t, clamp(sample + vec2u(1, 0), vec2u(1, 1), dims), 0);\n    let bl: vec4f = textureLoad(t, clamp(sample + vec2u(0, 1), vec2u(1, 1), dims), 0);\n    let br: vec4f = textureLoad(t, clamp(sample + vec2u(1, 1), vec2u(1, 1), dims), 0);\n    let f: vec2f = fract(uv);\n    let tA: vec4f = mix(tl, tr, f.x);\n    let tB: vec4f = mix(bl, br, f.x);\n    return mix(tA, tB, f.y);\n} \n\n@compute @workgroup_size(${ot[0]}, ${ot[1]}, 1)\nfn compute_main(\n  @builtin(workgroup_id) workGroupID : vec3<u32>,\n  @builtin(local_invocation_id) localInvocationID : vec3<u32>,\n  @builtin(global_invocation_id) globalInvocationID : vec3<u32>\n) {\n  // each thread adds a tile of pixels to the workgroups shared memory\n\n  let kernelArea: u32 = kernelSize * kernelSize;\n\n  // the kernel offset (number of pixels next to the center of the kernel) defines\n  // the border area next to the dispatched (=work) area that has to be included\n  // within the pixel cache\n  let kernelOffset: vec2u = vec2((kernelSize - 1) / 2);\n\n  // the local pixel offset of this threads tile\n  let tileOffset: vec2u = localInvocationID.xy * tileSize;\n\n  // the global pixel offset of the workgroup\n  let dispatchOffset: vec2u = workGroupID.xy * dispatchSize;\n\n  // get texture dimensions\n  let dims: vec2u = vec2<u32>(textureDimensions(inputTex, 0));\n  let seedDim: vec2u = vec2<u32>(textureDimensions(seedTex, 0));\n\n  // add this threads tiles pixels to the cache\n  for (var c=0u; c<tileSize.x; c++) {\n    for (var r=0u; r<tileSize.y; r++) {\n      let local: vec2u = vec2u(c, r) + tileOffset;\n\n      // subtract the kernel offset to include the border pixels needed\n      // for the convolution of the kernel within the dispatch (work) area\n      var sample: vec2u = dispatchOffset + local - kernelOffset;\n      var sampleUv: vec2f = vec2f(sample);\n      \n      // get the sample within the seed texture dimension\n      let seedSample: vec2u = vec2u((vec2f(sample) / vec2f(dims)) * vec2f(seedDim));\n      let seed: vec4f = textureLoad(seedTex, seedSample, 0);\n      \n      // offset the input sampling by the paint velocity\n      sampleUv -= normalize(seed.xy + .001) * max(0., min(.08, length(seed.xy)));\n      \n      // perform manual bilinear sampling of the input texture\n      let input: vec4f = texture2D_bilinear(inputTex, sampleUv, dims);\n      var value: vec4f = vec4f(input.rg, seed.xy);\n      \n      // fill in chemical b from the seed texture\n      let paint = clamp(seed.b, 0., 1.);\n      value.g = mix(input.g, (input.g + paint) / 2, seed.a);\n      value.r = mix(input.r, (input.r + (1. - paint)) / 2., seed.a);\n      value.g = clamp(value.g, 0., 1.);\n      value.r = clamp(value.r, 0., 1.);\n      \n      cache[local.y][local.x] = value;\n    }\n  }\n\n  workgroupBarrier();\n\n  // global pixel bounds within an application of the kernel is valid\n  let bounds: vec4u = vec4u(\n    dispatchOffset,\n    min(dims, dispatchOffset + dispatchSize)\n  );\n\n  let laplacian: array<f32, 9> = array(\n    0.05, 0.20, 0.05,\n    0.20, -1.0, 0.20,\n    0.05, 0.20, 0.05,\n  );\n\n  // run through the whole cache area\n  for (var c=0u; c<tileSize.x; c++) {\n    for (var r=0u; r<tileSize.y; r++) {\n      let local: vec2u = vec2u(c, r) + tileOffset;\n      let sample: vec2u = dispatchOffset + local - kernelOffset;\n\n      // only apply the kernel to pixels for which we have all\n      // necessary pixels in the cache\n      if (all(sample >= bounds.xy) && all(sample < bounds.zw)) {\n      \n        let uv: vec2f = vec2f(sample) / vec2f(dims);\n\n        // convolution with laplacian kernel\n        var lap = vec2f(0);\n        let ks: i32 = i32(kernelSize);\n        for (var x = 0; x < ks; x++) {\n          for (var y = 0; y < ks; y++) {\n            let i = vec2i(local) + vec2(x, y) - vec2i(kernelOffset);\n            lap += cache[i.y][i.x].xy * laplacian[y * ks + x];\n          }\n        }\n\n        // reaction diffusion calculation\n        let cacheValue: vec4f = cache[local.y][local.x];\n        let seedVel: vec2f = cacheValue.zw;\n        let seedVelLen: f32 = length(seedVel);\n        let rd0 = cacheValue.xy;\n        // update params from seed values\n        let rdScale = .9;\n        let dA = rdScale;\n        let dB = .3 * rdScale - min(0.1, max(0., seedVelLen * .5));\n        let feedInt = min(1., max(0., 1. - pow(seedVelLen - 1., 4.) - .1));\n        let killInt = min(1., max(0., pow(seedVelLen, 4.) + .4));\n        let feed = map(feedInt, 0., 1., 0.005, .095);\n        let kill = map(killInt, 0., 1., 0.055, .07);\n        // calculate result\n        let A = rd0.x;\n        let B = rd0.y;\n        let reaction = A * B * B;\n        let rd = vec2f(\n          A + (dA * lap.x - reaction + feed * (1. - A)),\n          B + (dB * lap.y + reaction - (kill + feed) * B),\n        );\n\n        textureStore(outputTex, sample, vec4(rd, 0., 1.0));\n\n        // debug code\n        //textureStore(outputTex, sample, vec4(cache[local.y][local.x], 1.0));\n        //textureStore(outputTex, sample, vec4(uv, 0., 1.0));\n      }\n    }\n  }\n}\n\n`,ft="This constructor is not a subclass of Float16Array",pt="The constructor property value is not an object",dt="Attempting to access detached ArrayBuffer",_t="Cannot convert undefined or null to object",mt="Cannot mix BigInt and other types, use explicit conversions",gt="@@iterator property is not callable",yt="Reduce of empty array with no initial value",wt="Offset is out of bounds";function vt(e){return(t,...n)=>kt(e,t,n)}function xt(e,t){return vt(Et(e,t).get)}const{apply:kt,construct:bt,defineProperty:Tt,get:St,getOwnPropertyDescriptor:Et,getPrototypeOf:At,has:zt,ownKeys:It,set:Mt,setPrototypeOf:Pt}=Reflect,Ut=Proxy,{EPSILON:Bt,MAX_SAFE_INTEGER:Vt,isFinite:Gt,isNaN:Nt}=Number,{iterator:Ot,species:qt,toStringTag:Dt,for:Rt}=Symbol,Ft=Object,{create:Lt,defineProperty:Ct,freeze:jt,is:$t}=Ft,Yt=Ft.prototype,Wt=Yt.__lookupGetter__?vt(Yt.__lookupGetter__):(e,t)=>{if(null==e)throw Rn(_t);let n=Ft(e);do{const e=Et(n,t);if(void 0!==e)return Xt(e,"get")?e.get:void 0}while(null!==(n=At(n)))},Xt=Ft.hasOwn||vt(Yt.hasOwnProperty),Ht=Array,Kt=Ht.isArray,Zt=Ht.prototype,Jt=vt(Zt.join),Qt=vt(Zt.push),en=vt(Zt.toLocaleString),tn=Zt[Ot],nn=vt(tn),{abs:rn,trunc:sn}=Math,on=ArrayBuffer,an=on.isView,un=on.prototype,cn=vt(un.slice),ln=xt(un,"byteLength"),hn="undefined"!=typeof SharedArrayBuffer?SharedArrayBuffer:null,fn=hn&&xt(hn.prototype,"byteLength"),pn=At(Uint8Array),dn=pn.from,_n=pn.prototype,mn=_n[Ot],gn=vt(_n.keys),yn=vt(_n.values),wn=vt(_n.entries),vn=vt(_n.set),xn=vt(_n.reverse),kn=vt(_n.fill),bn=vt(_n.copyWithin),Tn=vt(_n.sort),Sn=vt(_n.slice),En=vt(_n.subarray),An=xt(_n,"buffer"),zn=xt(_n,"byteOffset"),In=xt(_n,"length"),Mn=xt(_n,Dt),Pn=Uint8Array,Un=Uint16Array,Bn=(...e)=>kt(dn,Un,e),Vn=Uint32Array,Gn=Float32Array,Nn=At([][Ot]()),On=vt(Nn.next),qn=vt(function*(){}().next),Dn=At(Nn),Rn=TypeError,Fn=RangeError,Ln=WeakSet,Cn=Ln.prototype,jn=vt(Cn.add),$n=vt(Cn.has),Yn=WeakMap,Wn=Yn.prototype,Xn=vt(Wn.get),Hn=vt(Wn.has),Kn=vt(Wn.set),Zn=new Yn,Jn=Lt(null,{next:{value:function(){const e=Xn(Zn,this);return On(e)}},[Ot]:{value:function(){return this}}});function Qn(e){if(e[Ot]===tn&&Nn.next===On)return e;const t=Lt(Jn);return Kn(Zn,t,nn(e)),t}const er=new Yn,tr=Lt(Dn,{next:{value:function(){const e=Xn(er,this);return qn(e)},writable:!0,configurable:!0}});for(const hs of It(Nn))"next"!==hs&&Ct(tr,hs,Et(Nn,hs));function nr(e){const t=Lt(tr);return Kn(er,t,e),t}function rr(e){return null!==e&&"object"==typeof e||"function"==typeof e}function sr(e){return null!==e&&"object"==typeof e}function ir(e){return void 0!==Mn(e)}function or(e){const t=Mn(e);return"BigInt64Array"===t||"BigUint64Array"===t}function ar(e){if(null===hn)return!1;try{return fn(e),!0}catch(t){return!1}}function ur(e){return function(e){try{return!Kt(e)&&(ln(e),!0)}catch(t){return!1}}(e)||ar(e)}function cr(e){return!!Kt(e)&&(e[Ot]===tn&&Nn.next===On)}function lr(e){if("string"!=typeof e)return!1;const t=+e;return e===t+""&&(!!Gt(t)&&t===sn(t))}const hr=Rt("__Float16Array__");const fr=1/Bt;const pr=6103515625e-14,dr=65504,_r=.0009765625,mr=_r*pr,gr=_r*fr;function yr(e){const t=+e;if(!Gt(t)||0===t)return t;const n=t>0?1:-1,r=rn(t);if(r<pr)return n*function(e){return e+fr-fr}(r/mr)*mr;const s=(1+gr)*r,i=s-(s-r);return i>dr||Nt(i)?n*(1/0):n*i}const wr=new on(4),vr=new Gn(wr),xr=new Vn(wr),kr=new Un(512),br=new Pn(512);for(let hs=0;hs<256;++hs){const e=hs-127;e<-27?(kr[hs]=0,kr[256|hs]=32768,br[hs]=24,br[256|hs]=24):e<-14?(kr[hs]=1024>>-e-14,kr[256|hs]=1024>>-e-14|32768,br[hs]=-e-1,br[256|hs]=-e-1):e<=15?(kr[hs]=e+15<<10,kr[256|hs]=e+15<<10|32768,br[hs]=13,br[256|hs]=13):e<128?(kr[hs]=31744,kr[256|hs]=64512,br[hs]=24,br[256|hs]=24):(kr[hs]=31744,kr[256|hs]=64512,br[hs]=13,br[256|hs]=13)}function Tr(e){vr[0]=yr(e);const t=xr[0],n=t>>23&511;return kr[n]+((8388607&t)>>br[n])}const Sr=new Vn(2048);for(let hs=1;hs<1024;++hs){let e=hs<<13,t=0;for(;!(8388608&e);)e<<=1,t-=8388608;e&=-8388609,t+=947912704,Sr[hs]=e|t}for(let hs=1024;hs<2048;++hs)Sr[hs]=939524096+(hs-1024<<13);const Er=new Vn(64);for(let hs=1;hs<31;++hs)Er[hs]=hs<<23;Er[31]=1199570944,Er[32]=2147483648;for(let hs=33;hs<63;++hs)Er[hs]=2147483648+(hs-32<<23);Er[63]=3347054592;const Ar=new Un(64);for(let hs=1;hs<64;++hs)32!==hs&&(Ar[hs]=1024);function zr(e){const t=e>>10;return xr[0]=Sr[Ar[t]+(1023&e)]+Er[t],vr[0]}function Ir(e){const t=+e;return Nt(t)||0===t?0:sn(t)}function Mr(e){const t=Ir(e);return t<0?0:t<Vt?t:Vt}function Pr(e,t){if(!rr(e))throw Rn("This is not an object");const n=e.constructor;if(void 0===n)return t;if(!rr(n))throw Rn(pt);const r=n[qt];return null==r?t:r}function Ur(e){if(ar(e))return!1;try{return cn(e,0,0),!1}catch(t){}return!0}function Br(e,t){const n=Nt(e),r=Nt(t);if(n&&r)return 0;if(n)return 1;if(r)return-1;if(e<t)return-1;if(e>t)return 1;if(0===e&&0===t){const n=$t(e,0),r=$t(t,0);if(!n&&r)return-1;if(n&&!r)return 1}return 0}const Vr=new Yn;function Gr(e){return Hn(Vr,e)||!an(e)&&function(e){if(!sr(e))return!1;const t=At(e);if(!sr(t))return!1;const n=t.constructor;if(void 0===n)return!1;if(!rr(n))throw Rn(pt);return zt(n,hr)}(e)}function Nr(e){if(!Gr(e))throw Rn("This is not a Float16Array object")}function Or(e,t){const n=Gr(e),r=ir(e);if(!n&&!r)throw Rn("Species constructor didn't return TypedArray object");if("number"==typeof t){let r;if(n){const t=qr(e);r=In(t)}else r=In(e);if(r<t)throw Rn("Derived constructor created TypedArray object which was too small length")}if(or(e))throw Rn(mt)}function qr(e){const t=Xn(Vr,e);if(void 0!==t){if(Ur(An(t)))throw Rn(dt);return t}const n=e.buffer;if(Ur(n))throw Rn(dt);const r=bt(Lr,[n,e.byteOffset,e.length],e.constructor);return Xn(Vr,r)}function Dr(e){const t=In(e),n=[];for(let r=0;r<t;++r)n[r]=zr(e[r]);return n}const Rr=new Ln;for(const hs of It(_n)){if(hs===Dt)continue;const e=Et(_n,hs);Xt(e,"get")&&"function"==typeof e.get&&jn(Rr,e.get)}const Fr=jt({get:(e,t,n)=>lr(t)&&Xt(e,t)?zr(St(e,t)):$n(Rr,Wt(e,t))?St(e,t):St(e,t,n),set:(e,t,n,r)=>lr(t)&&Xt(e,t)?Mt(e,t,Tr(n)):Mt(e,t,n,r),getOwnPropertyDescriptor(e,t){if(lr(t)&&Xt(e,t)){const n=Et(e,t);return n.value=zr(n.value),n}return Et(e,t)},defineProperty:(e,t,n)=>lr(t)&&Xt(e,t)&&Xt(n,"value")?(n.value=Tr(n.value),Tt(e,t,n)):Tt(e,t,n)});class Lr{constructor(e,t,n){let r;if(Gr(e))r=bt(Un,[qr(e)],new.target);else if(rr(e)&&!ur(e)){let t,n;if(ir(e)){t=e,n=In(e);if(Ur(An(e)))throw Rn(dt);if(or(e))throw Rn(mt);const s=new on(2*n);r=bt(Un,[s],new.target)}else{const s=e[Ot];if(null!=s&&"function"!=typeof s)throw Rn(gt);null!=s?cr(e)?(t=e,n=e.length):(t=[...e],n=t.length):(t=e,n=Mr(t.length)),r=bt(Un,[n],new.target)}for(let e=0;e<n;++e)r[e]=Tr(t[e])}else r=bt(Un,arguments,new.target);const s=new Ut(r,Fr);return Kn(Vr,s,r),s}static from(e,...t){const n=this;if(!zt(n,hr))throw Rn(ft);if(n===Lr){if(Gr(e)&&0===t.length){const t=qr(e),n=new Un(An(t),zn(t),In(t));return new Lr(An(Sn(n)))}if(0===t.length)return new Lr(An(Bn(e,Tr)));const n=t[0],r=t[1];return new Lr(An(Bn(e,(function(e,...t){return Tr(kt(n,this,[e,...Qn(t)]))}),r)))}let r,s;const i=e[Ot];if(null!=i&&"function"!=typeof i)throw Rn(gt);if(null!=i)cr(e)?(r=e,s=e.length):ir(o=e)&&o[Ot]===mn&&Nn.next===On?(r=e,s=In(e)):(r=[...e],s=r.length);else{if(null==e)throw Rn(_t);r=Ft(e),s=Mr(r.length)}var o;const a=new n(s);if(0===t.length)for(let u=0;u<s;++u)a[u]=r[u];else{const e=t[0],n=t[1];for(let t=0;t<s;++t)a[t]=kt(e,n,[r[t],t])}return a}static of(...e){const t=this;if(!zt(t,hr))throw Rn(ft);const n=e.length;if(t===Lr){const t=new Lr(n),r=qr(t);for(let s=0;s<n;++s)r[s]=Tr(e[s]);return t}const r=new t(n);for(let s=0;s<n;++s)r[s]=e[s];return r}keys(){Nr(this);const e=qr(this);return gn(e)}values(){Nr(this);const e=qr(this);return nr(function*(){for(const t of yn(e))yield zr(t)}())}entries(){Nr(this);const e=qr(this);return nr(function*(){for(const[t,n]of wn(e))yield[t,zr(n)]}())}at(e){Nr(this);const t=qr(this),n=In(t),r=Ir(e),s=r>=0?r:n+r;if(!(s<0||s>=n))return zr(t[s])}with(e,t){Nr(this);const n=qr(this),r=In(n),s=Ir(e),i=s>=0?s:r+s,o=+t;if(i<0||i>=r)throw Fn(wt);const a=new Un(An(n),zn(n),In(n)),u=new Lr(An(Sn(a)));return qr(u)[i]=Tr(o),u}map(e,...t){Nr(this);const n=qr(this),r=In(n),s=t[0],i=Pr(n,Lr);if(i===Lr){const t=new Lr(r),i=qr(t);for(let o=0;o<r;++o){const t=zr(n[o]);i[o]=Tr(kt(e,s,[t,o,this]))}return t}const o=new i(r);Or(o,r);for(let a=0;a<r;++a){const t=zr(n[a]);o[a]=kt(e,s,[t,a,this])}return o}filter(e,...t){Nr(this);const n=qr(this),r=In(n),s=t[0],i=[];for(let a=0;a<r;++a){const t=zr(n[a]);kt(e,s,[t,a,this])&&Qt(i,t)}const o=new(Pr(n,Lr))(i);return Or(o),o}reduce(e,...t){Nr(this);const n=qr(this),r=In(n);if(0===r&&0===t.length)throw Rn(yt);let s,i;0===t.length?(s=zr(n[0]),i=1):(s=t[0],i=0);for(let o=i;o<r;++o)s=e(s,zr(n[o]),o,this);return s}reduceRight(e,...t){Nr(this);const n=qr(this),r=In(n);if(0===r&&0===t.length)throw Rn(yt);let s,i;0===t.length?(s=zr(n[r-1]),i=r-2):(s=t[0],i=r-1);for(let o=i;o>=0;--o)s=e(s,zr(n[o]),o,this);return s}forEach(e,...t){Nr(this);const n=qr(this),r=In(n),s=t[0];for(let i=0;i<r;++i)kt(e,s,[zr(n[i]),i,this])}find(e,...t){Nr(this);const n=qr(this),r=In(n),s=t[0];for(let i=0;i<r;++i){const t=zr(n[i]);if(kt(e,s,[t,i,this]))return t}}findIndex(e,...t){Nr(this);const n=qr(this),r=In(n),s=t[0];for(let i=0;i<r;++i){const t=zr(n[i]);if(kt(e,s,[t,i,this]))return i}return-1}findLast(e,...t){Nr(this);const n=qr(this),r=In(n),s=t[0];for(let i=r-1;i>=0;--i){const t=zr(n[i]);if(kt(e,s,[t,i,this]))return t}}findLastIndex(e,...t){Nr(this);const n=qr(this),r=In(n),s=t[0];for(let i=r-1;i>=0;--i){const t=zr(n[i]);if(kt(e,s,[t,i,this]))return i}return-1}every(e,...t){Nr(this);const n=qr(this),r=In(n),s=t[0];for(let i=0;i<r;++i)if(!kt(e,s,[zr(n[i]),i,this]))return!1;return!0}some(e,...t){Nr(this);const n=qr(this),r=In(n),s=t[0];for(let i=0;i<r;++i)if(kt(e,s,[zr(n[i]),i,this]))return!0;return!1}set(e,...t){Nr(this);const n=qr(this),r=Ir(t[0]);if(r<0)throw Fn(wt);if(null==e)throw Rn(_t);if(or(e))throw Rn(mt);if(Gr(e))return vn(qr(this),qr(e),r);if(ir(e)){if(Ur(An(e)))throw Rn(dt)}const s=In(n),i=Ft(e),o=Mr(i.length);if(r===1/0||o+r>s)throw Fn(wt);for(let a=0;a<o;++a)n[a+r]=Tr(i[a])}reverse(){Nr(this);const e=qr(this);return xn(e),this}toReversed(){Nr(this);const e=qr(this),t=new Un(An(e),zn(e),In(e)),n=new Lr(An(Sn(t))),r=qr(n);return xn(r),n}fill(e,...t){Nr(this);const n=qr(this);return kn(n,Tr(e),...Qn(t)),this}copyWithin(e,t,...n){Nr(this);const r=qr(this);return bn(r,e,t,...Qn(n)),this}sort(e){Nr(this);const t=qr(this),n=void 0!==e?e:Br;return Tn(t,((e,t)=>n(zr(e),zr(t)))),this}toSorted(e){Nr(this);const t=qr(this);if(void 0!==e&&"function"!=typeof e)throw new Rn("The comparison function must be either a function or undefined");const n=void 0!==e?e:Br,r=new Un(An(t),zn(t),In(t)),s=new Lr(An(Sn(r))),i=qr(s);return Tn(i,((e,t)=>n(zr(e),zr(t)))),s}slice(e,t){Nr(this);const n=qr(this),r=Pr(n,Lr);if(r===Lr){const r=new Un(An(n),zn(n),In(n));return new Lr(An(Sn(r,e,t)))}const s=In(n),i=Ir(e),o=void 0===t?s:Ir(t);let a,u;a=i===-1/0?0:i<0?s+i>0?s+i:0:s<i?s:i,u=o===-1/0?0:o<0?s+o>0?s+o:0:s<o?s:o;const c=u-a>0?u-a:0,l=new r(c);if(Or(l,c),0===c)return l;if(Ur(An(n)))throw Rn(dt);let h=0;for(;a<u;)l[h]=zr(n[a]),++a,++h;return l}subarray(e,t){Nr(this);const n=qr(this),r=Pr(n,Lr),s=new Un(An(n),zn(n),In(n)),i=En(s,e,t),o=new r(An(i),zn(i),In(i));return Or(o),o}indexOf(e,...t){Nr(this);const n=qr(this),r=In(n);let s=Ir(t[0]);if(s===1/0)return-1;s<0&&(s+=r,s<0&&(s=0));for(let i=s;i<r;++i)if(Xt(n,i)&&zr(n[i])===e)return i;return-1}lastIndexOf(e,...t){Nr(this);const n=qr(this),r=In(n);let s=t.length>=1?Ir(t[0]):r-1;if(s===-1/0)return-1;s>=0?s=s<r-1?s:r-1:s+=r;for(let i=s;i>=0;--i)if(Xt(n,i)&&zr(n[i])===e)return i;return-1}includes(e,...t){Nr(this);const n=qr(this),r=In(n);let s=Ir(t[0]);if(s===1/0)return!1;s<0&&(s+=r,s<0&&(s=0));const i=Nt(e);for(let o=s;o<r;++o){const t=zr(n[o]);if(i&&Nt(t))return!0;if(t===e)return!0}return!1}join(e){Nr(this);const t=Dr(qr(this));return Jt(t,e)}toLocaleString(...e){Nr(this);const t=Dr(qr(this));return en(t,...Qn(e))}get[Dt](){if(Gr(this))return"Float16Array"}}Ct(Lr,"BYTES_PER_ELEMENT",{value:2}),Ct(Lr,hr,{}),Pt(Lr,pn);const Cr=Lr.prototype;Ct(Cr,"BYTES_PER_ELEMENT",{value:2}),Ct(Cr,Ot,{value:Cr.values,writable:!0,configurable:!0}),Pt(Cr,_n);class jr{constructor(e,n){t(this,"ITERATIONS",10),this.renderer=e,this.paint=n;const r=this.renderer.device.createShaderModule({code:ht}),s=tt(ht);this.pipelineDescriptor={compute:{module:r,entryPoint:"compute_main"}};const i=Ye(s,this.pipelineDescriptor);i[0].entries.push({binding:2,storageTexture:{access:"write-only",format:"rgba16float"},visibility:GPUShaderStage.COMPUTE}),this.bindGroupLayout=this.renderer.device.createBindGroupLayout(i[0]);const o=this.renderer.device.createPipelineLayout({bindGroupLayouts:[this.bindGroupLayout]});this.computePipeline=this.renderer.device.createComputePipeline({label:"reaction diffusion compute pipeline",layout:o,...this.pipelineDescriptor}),this.emptyTexture=this.renderer.device.createTexture({label:"empty texture",size:[1,1],dimension:"2d",format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST}),this.init(100,100)}init(e,t){this.createTextures(e,t),this.createBindGroups()}get resultStorageTexture(){return this.swapTextures[0]}createTextures(e,t){this.swapTextures&&this.swapTextures.forEach((e=>e.destroy())),this.swapTextures=new Array(2).fill(null).map(((n,r)=>{const s=this.renderer.device.createTexture({size:{width:e,height:t},format:"rgba16float",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT}),i=e,o=t;let a;const u=new Array(i*o*4).fill(0);for(let e=0;e<i;e++)for(let t=0;t<o;t++)u[4*(e+t*i)+0]=1,u[4*(e+t*i)+1]=0,u[4*(e+t*i)+2]=0,u[4*(e+t*i)+3]=1;return a=new Lr(u),this.renderer.device.queue.writeTexture({texture:s},a.buffer,{bytesPerRow:8*e},{width:e,height:t}),s})),this.dispatches=[Math.ceil(e/lt[0]),Math.ceil(t/lt[1])]}createBindGroups(){this.swapBindGroups=[this.renderer.device.createBindGroup({layout:this.bindGroupLayout,entries:[{binding:0,resource:this.paint.resultStorageTexture.createView()},{binding:1,resource:this.swapTextures[0].createView()},{binding:2,resource:this.swapTextures[1].createView()}]}),this.renderer.device.createBindGroup({layout:this.bindGroupLayout,entries:[{binding:0,resource:this.paint.resultStorageTexture.createView()},{binding:1,resource:this.swapTextures[1].createView()},{binding:2,resource:this.swapTextures[0].createView()}]})]}compute(e){e.setPipeline(this.computePipeline);for(let t=0;t<this.ITERATIONS;t++)e.setBindGroup(0,this.swapBindGroups[0]),e.dispatchWorkgroups(this.dispatches[0],this.dispatches[1]),e.setBindGroup(0,this.swapBindGroups[1]),e.dispatchWorkgroups(this.dispatches[0],this.dispatches[1])}}const $r=[8,8],Yr=[3,3],Wr=[Yr[0]*$r[0],Yr[1]*$r[1]],Xr=Wr,Hr=`\n\nstruct RenderInfo {\n    viewportSize: vec2f,\n    deltaTimeMS: f32,\n    timeMS: f32\n};\n\nstruct PointerInfo {\n    position: vec2f,\n    previousPosition: vec2f,\n    velocity: vec2f,\n    previousVelocity: vec2f,\n};\n\nconst dispatchSize = vec2u(${Wr[0]},${Wr[1]});\nconst tileSize = vec2u(${Yr[0]},${Yr[1]});\n\n@group(0) @binding(0) var<uniform> renderInfo: RenderInfo;\n@group(0) @binding(1) var<uniform> pointerInfo: PointerInfo;\n@group(1) @binding(0) var inputTex: texture_2d<f32>;\n@group(1) @binding(1) var outputTex: texture_storage_2d<rgba16float, write>;\n\nfn sdSegment( p: vec2f, a: vec2f, b: vec2f ) -> vec2f {\n    let pa = p-a;\n    let ba = b-a;\n    let h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return vec2f(length( pa - ba*h ), h);\n}\n\nfn rand_f32(n: f32) -> f32 { return fract(sin(n) * 43758.5453123); }\n\nfn rand_vec2f(n: vec2f) -> f32 { \n    return fract(sin(dot(n, vec2f(12.9898, 4.1414))) * 43758.5453);\n}\n\nfn noise_f32(p: f32) -> f32 {\n    let fl = floor(p);\n    let fc = fract(p);\n    return mix(rand_f32(fl), rand_f32(fl + 1.0), fc);\n}\n\nfn noise_vec2f(n: vec2f) -> f32 {\n    let d: vec2f = vec2f(0.0, 1.0);\n    let b: vec2f = floor(n);\n    let f: vec2f = smoothstep(vec2f(0.0), vec2f(1.0), fract(n));\n    return mix(mix(rand_vec2f(b), rand_vec2f(b + d.yx), f.x), mix(rand_vec2f(b + d.xy), rand_vec2f(b + d.yy), f.x), f.y);\n}\n\n@compute @workgroup_size(${$r[0]}, ${$r[1]}, 1)\nfn compute_main(\n  @builtin(workgroup_id) workGroupID : vec3<u32>,\n  @builtin(local_invocation_id) localInvocationID : vec3<u32>,\n  @builtin(global_invocation_id) globalInvocationID : vec3<u32>\n) {\n  // the local pixel offset of this threads tile\n  let tileOffset: vec2u = localInvocationID.xy * tileSize;\n\n  // the global pixel offset of the workgroup\n  let dispatchOffset: vec2u = workGroupID.xy * dispatchSize;\n  \n  let dims: vec2u = vec2<u32>(textureDimensions(inputTex, 0));\n  let deviceSizeFactor = 3. - clamp((f32(max(dims.x, dims.y)) / 800.), 0., 3.);\n  \n  let aspectFactor: vec2f = vec2f(dims) / f32(max(dims.x, dims.y));\n\n  // run through the whole tile\n  for (var c=0u; c<tileSize.x; c++) {\n    for (var r=0u; r<tileSize.y; r++) {\n      let local: vec2u = vec2u(c, r) + tileOffset;\n      let sample: vec2u = dispatchOffset + local;\n      let inputValue = textureLoad(inputTex, sample, 0);\n      \n      // get the uv coords from the sample position to calculate the signed distance field value\n      var uv: vec2f = vec2f(sample) / vec2f(dims);\n      \n      // aspect correction\n      let st = ((uv * 2. - 1.) * aspectFactor) * .5 + .5;\n      let pointerPos = ((pointerInfo.position * 2. - 1.) * aspectFactor) * .5 + .5;\n      let prevPointerPos = ((pointerInfo.previousPosition * 2. - 1.) * aspectFactor) * .5 + .5;\n      \n      // get the distance to the segment to draw\n      let sdf = sdSegment(st, pointerPos, prevPointerPos);\n      let dist = max(0., sdf.x);\n      \n      // calculate the radius for the new and previous point\n      let radiusScale = 1.5;\n      let offset = pointerInfo.velocity * renderInfo.deltaTimeMS;\n      let strength = length(offset);\n      let newRadius = strength * radiusScale;\n      let prevOffset = pointerInfo.previousVelocity * renderInfo.deltaTimeMS;\n      let prevRadius = length(prevOffset) * radiusScale;\n      \n      // interpolate between previous and new radius over the segment length\n      var radius = newRadius * (1. - sdf.y) + prevRadius * sdf.y;\n      radius = clamp(radius, 0.0, .1);\n      \n      // generate velocity noise\n      let normPointerVel = normalize(pointerInfo.velocity);\n      let pointerBase = mat2x2f(normPointerVel, vec2f(normPointerVel.y, -normPointerVel.x));\n      let noiseDir = pointerBase * (st - pointerInfo.position);\n      var noiseVel: vec2f = vec2f(\n        noise_vec2f(noiseDir * vec2f(35., 15.) + renderInfo.timeMS * 0.01) * 4. - 2.,\n        noise_vec2f(noiseDir * vec2f(10., 30.) + renderInfo.timeMS * 0.001) * 2. - 1.\n      );\n      \n      // get a smooth paint from the distance to the segment\n      let smoothness = .05 * deviceSizeFactor;\n      var paint = 1. - smoothstep(radius, radius + smoothness, dist + smoothness * .4 + noiseVel.y * .01);\n      \n      // the strength according to the velocity\n      paint = min(1., paint * strength * 200.);\n      \n      // the velocity has more influence than the actual paint\n      let velocityMaskRadius = radius * 4.;\n      let velocityMaskSmoothness = .05;\n      let velocityMask = 1. - smoothstep(velocityMaskRadius, velocityMaskRadius + velocityMaskSmoothness, dist + velocityMaskSmoothness * .2 + noiseVel.x * .01);\n      // amplify the pointer velocity\n      var vel: vec2f = pointerInfo.velocity * 1000.;\n      // mask the velocity\n      vel *= velocityMask;\n      // combine the new velocity with a bit of the current samples velocity\n      vel = (inputValue.xy + vel) / 2.;\n      \n      // calculate the general flow field velocity for this sample (center force)\n      var flowVel = (st * 2. - 1.);\n      flowVel = normalize(flowVel) * min(0.25, max(0., (length(flowVel))));\n      // add a little bit of force from the current pointer position\n      var pointerOffsetVel = pointerInfo.position - uv;\n      pointerOffsetVel = normalize(pointerOffsetVel) * (1. - smoothstep(0., 1., length(pointerOffsetVel)));\n      flowVel -= pointerOffsetVel * 0.1;\n      \n      // find the input value which was moved to this samples location\n      let velOffsetStrength = .015;\n      let velOffset: vec2u = vec2u((uv - (vel * 2. + flowVel + noiseVel * .1) * velOffsetStrength) * vec2f(dims));\n      let offsetInputValue = textureLoad(inputTex, velOffset, 0);\n      \n      // combine with the previous paint\n      paint += offsetInputValue.b;\n      paint = clamp(paint, 0., 1.);\n      // dissipate the paint over time\n      paint *= 0.925;\n\n      // move velocity\n      vel = (offsetInputValue.xy * 1.5 + vel) / 2.;\n      // dissipate the velocity over time\n      vel *= 0.96;\n      \n      var result: vec4f = vec4(vec4(vel, paint, paint));\n      //var result: vec4f = vec4(vec4(step(vec2f(0.5), st), paint, paint));\n\n      textureStore(outputTex, sample, result);\n    }\n  }\n}\n\n`;class Kr{constructor(e){t(this,"pointerInfo",{position:[0,0],velocity:[0,0],previousPosition:[0,0],previousVelocity:[0,0]}),this.renderer=e;const n=this.renderer.device.createShaderModule({code:Hr}),r=tt(Hr);this.pipelineDescriptor={compute:{module:n,entryPoint:"compute_main"}};const s=Ye(r,this.pipelineDescriptor);s[1].entries.push({binding:1,storageTexture:{access:"write-only",format:"rgba16float"},visibility:GPUShaderStage.COMPUTE}),this.texturesBindGroupLayout=this.renderer.device.createBindGroupLayout(s[1]);const i=b(r.uniforms.renderInfo);this.renderInfoUniform={view:i,buffer:e.device.createBuffer({size:i.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})};const o=b(r.uniforms.pointerInfo);this.pointerInfoUniform={view:o,buffer:e.device.createBuffer({size:o.arrayBuffer.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})};const a=this.renderer.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:this.renderInfoUniform.buffer},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:this.pointerInfoUniform.buffer}]});this.uniformsBindGroup=this.renderer.device.createBindGroup({layout:a,entries:[{binding:0,resource:{buffer:this.renderInfoUniform.buffer}},{binding:1,resource:{buffer:this.pointerInfoUniform.buffer}}]});const u=this.renderer.device.createPipelineLayout({bindGroupLayouts:[a,this.texturesBindGroupLayout]});this.computePipeline=this.renderer.device.createComputePipeline({label:"paint compute pipeline",layout:u,...this.pipelineDescriptor}),this.init(100,100)}init(e,t){this.currentSwapIndex=0,this.pointerVelocityAttenuation=Math.min(1,Math.max(e,t)/1400),this.createTextures(e,t),this.createTexturesBindGroups()}get resultStorageTexture(){return this.swapTextures[0]}createTextures(e,t){this.swapTextures&&this.swapTextures.forEach((e=>e.destroy())),this.swapTextures=new Array(2).fill(null).map(((n,r)=>this.renderer.device.createTexture({size:{width:e,height:t},format:"rgba16float",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT}))),this.dispatches=[Math.ceil(e/Xr[0]),Math.ceil(t/Xr[1])]}createTexturesBindGroups(){this.swapBindGroups=[this.renderer.device.createBindGroup({layout:this.texturesBindGroupLayout,entries:[{binding:0,resource:this.swapTextures[0].createView()},{binding:1,resource:this.swapTextures[1].createView()}]}),this.renderer.device.createBindGroup({layout:this.texturesBindGroupLayout,entries:[{binding:0,resource:this.swapTextures[1].createView()},{binding:1,resource:this.swapTextures[0].createView()}]})]}compute(e,t,n){this.pointerInfo.position=n.position,this.pointerInfo.previousPosition=n.previousPosition;const r=[(n.position[0]-n.previousPosition[0])/t.deltaTimeMS,(n.position[1]-n.previousPosition[1])/t.deltaTimeMS];r[0]*=this.pointerVelocityAttenuation,r[1]*=this.pointerVelocityAttenuation;const s=n.isDown?20:4;this.pointerInfo.velocity=[this.pointerInfo.velocity[0]+(r[0]-this.pointerInfo.velocity[0])/s,this.pointerInfo.velocity[1]+(r[1]-this.pointerInfo.velocity[1])/s];const i=this.renderer.getSize().map((e=>e/this.renderer.devicePixelRatio));this.renderInfoUniform.view.set({viewportSize:i,deltaTimeMS:t.deltaTimeMS,timeMS:t.timeMS}),this.pointerInfoUniform.view.set(this.pointerInfo),this.renderer.device.queue.writeBuffer(this.renderInfoUniform.buffer,0,this.renderInfoUniform.view.arrayBuffer),this.renderer.device.queue.writeBuffer(this.pointerInfoUniform.buffer,0,this.pointerInfoUniform.view.arrayBuffer),e.setPipeline(this.computePipeline),e.setBindGroup(0,this.uniformsBindGroup),e.setBindGroup(1,this.swapBindGroups[this.currentSwapIndex]),e.dispatchWorkgroups(this.dispatches[0],this.dispatches[1]),this.currentSwapIndex=(this.currentSwapIndex+1)%2,this.pointerInfo.previousVelocity=[...this.pointerInfo.velocity]}}let Zr,Jr,Qr,es,ts;const ns=.25,rs=.5,ss={TARGET_FRAME_DURATION_MS:16,timeMS:0,deltaTimeMS:0,frames:0,deltaFrames:0},is={isDown:!1,position:[0,0],previousPosition:[0,0]};function os(e){const t=Jr.getSize().map((e=>e/window.devicePixelRatio));return[e.clientX/t[0],1-e.clientY/t[1]]}function as(e){is.isDown=!1}function us(e=0){!function(e){ss.deltaTimeMS=Math.max(1,Math.min(2*ss.TARGET_FRAME_DURATION_MS,e-ss.timeMS)),ss.timeMS=e,ss.deltaFrames=ss.deltaTimeMS/ss.TARGET_FRAME_DURATION_MS,ss.frames+=ss.deltaFrames}(e);const t=Jr.device.createCommandEncoder();!function(e){const t=e.beginComputePass();Qr.compute(t,ss,is),es.compute(t),t.end(),is.previousPosition=[...is.position]}(t),function(e){const t=e.beginRenderPass({...ts.renderPassDescriptor});ts.render(t),t.end()}(t),Jr.device.queue.submit([t.finish()]),requestAnimationFrame((e=>us(e)))}const cs={init:async function(){var e;const t=await(null==(e=navigator.gpu)?void 0:e.requestAdapter());if(!t)return;const r=document.querySelector("canvas");Zr=Math.min(2,window.devicePixelRatio),Jr=new n(r,Zr),await Jr.init(t),Qr=new Kr(Jr),es=new jr(Jr,Qr),ts=new it(Jr,Qr,es),await ts.init(),function(e){e.addEventListener("pointerdown",(e=>function(e){is.isDown=!0,is.position=os(e),is.previousPosition=[...is.position]}(e))),e.addEventListener("pointerup",(e=>as())),e.addEventListener("pointerleave",(e=>as())),e.addEventListener("pointermove",(e=>function(e){if(!is.isDown)return;is.position=os(e)}(e)))}(r),function(e){new ResizeObserver((e=>{const t=e[0],n=t.contentBoxSize,r=t.devicePixelContentBoxSize;!function(e,t){if(e<=1||t<=1)return;Jr.setSize(e,t);const n=Jr.getSize();Qr.init(Math.round(n[0]*rs),Math.round(n[1]*rs)),es.init(Math.round(n[0]*ns),Math.round(n[1]*ns)),ts.setSize(n[0],n[1])}((null==r?void 0:r[0].inlineSize)||n[0].inlineSize*Zr,(null==r?void 0:r[0].blockSize)||n[0].blockSize*Zr)})).observe(e)}(r),us(0)}},ls=document.querySelector("#no-webgpu");!async function(){!navigator.gpu?ls.style.display="":await cs.init()}();
